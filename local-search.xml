<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>十个常见的排序算法</title>
    <link href="/2020/10/12/2020-10-12-ten-sort-alogrithm/"/>
    <url>/2020/10/12/2020-10-12-ten-sort-alogrithm/</url>
    
    <content type="html"><![CDATA[<center style='font-size: 18px; font-weight: bold;'>常见的内部排序算法</center><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201012110529.png" alt="image-20201012110323047"></p><p>名词解释：</p><ul><li>n：数据规模</li><li>k：”桶”的个数</li><li>In-place：占用常数内存，不占用额外内存</li><li>Out-place：占用额外内存</li><li>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p><p>接下来详细地介绍下着十大经典的排序算法。</p><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><p>冒泡排序（Bubble Sort）是一种简单的<strong>排序算法</strong>。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为<strong>越小的元素会经由交换慢慢“浮”到数列的顶端</strong>。</p><p><strong>算法步骤：</strong></p><ul><li>较相邻的元素，如果前者比后者大，则交换两个元素</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对</li><li>针对所有的元素重复以上的步骤，除了最后一个</li><li>重复上面三个步骤，直到没有任何一对数字需要比较</li></ul><p><strong>演示动图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201012131013.gif" alt="bubbo"></p><p><strong>Java 代码实现</strong></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] bubbleSort(<span class="hljs-keyword">int</span>[] arr) &#123;    <span class="hljs-comment">// 直接进行冒泡排序</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> len = arr.length;    <span class="hljs-comment">// i表示第几趟排序 遍历n-1次</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-comment">// j表示排序次数</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len - i; j++) &#123;            <span class="hljs-comment">// 让小的数字冒泡上浮 大数下沉</span>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">int</span> temp = arr[j + <span class="hljs-number">1</span>];                arr[j + <span class="hljs-number">1</span>] = arr[j];                arr[j] = temp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre><p>若序列中的大部分元素已经预先排好序，那么使用冒泡排序简直浪费生命，故可以针对局部元素已排好序的情况进行改进。</p><p><strong>改进后的冒泡排序算法</strong></p><pre><code class="hljs java"><span class="hljs-comment">// 优化后的冒泡排序: 若当前数组子集没有交换过 代表已经排序完成 看后续元素</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] proveBubble(<span class="hljs-keyword">int</span>[] arr) &#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> len = arr.length;    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">// i表示第几趟排序 遍历n-1次</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-comment">// j表示排序次数</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++) &#123;            <span class="hljs-comment">// 让小的数字冒泡上浮 大数下沉</span>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;                flag = <span class="hljs-keyword">true</span>;                <span class="hljs-keyword">int</span> temp = arr[j + <span class="hljs-number">1</span>];                arr[j + <span class="hljs-number">1</span>] = arr[j];                arr[j] = temp;            &#125;        &#125;        <span class="hljs-keyword">if</span> (flag) &#123;            flag = <span class="hljs-keyword">false</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好，不占用额外的内存空间了。</p><p><strong>算法步骤</strong></p><ol><li>在序列中找到最小（大）元素</li><li>把它存放到排序序列的起始位置</li><li>重复 1 和 2 两个步骤，直到所有元素均排序完毕</li></ol><p><strong>动图演示</strong></p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201012134051.gif" alt="直接选择排序.gif"></p><p><strong>Java 代码实现</strong></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] selectSort(<span class="hljs-keyword">int</span>[] arr) &#123;    <span class="hljs-comment">// 总共要经过 N-1 轮比较</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">int</span> min = i;        <span class="hljs-comment">// 每轮需要比较的次数 N-i</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min]) &#123;                <span class="hljs-comment">// 记录目前能找到的最小值元素的下标</span>                min = j;            &#125;        &#125;        <span class="hljs-comment">// 当最小值索引有变动 交换两数索引</span>        <span class="hljs-keyword">if</span> (i != min) &#123;            <span class="hljs-keyword">int</span> tmp = arr[i];            arr[i] = arr[min];            arr[min] = tmp;        &#125;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h2><p>插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，<strong>对于未排序数据，在已排序序列中从后向前扫描</strong>，找到相应位置并插入。</p><p>插入排序在实现上，通常采用<strong>原地排序</strong>（即只需用到 O(1) 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p><strong>算法步骤</strong></p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤 2~5，直到所有元素排序完毕</li></ol><p><strong>动图演示</strong></p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201012135948.gif" alt="img"></p><p><strong>Java 代码实现</strong></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] insertSort(<span class="hljs-keyword">int</span>[] arr) &#123;    <span class="hljs-comment">// 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;        <span class="hljs-comment">// 记录要插入的数据</span>        <span class="hljs-keyword">int</span> tmp = arr[i];        <span class="hljs-comment">// 记录待插入点</span>        <span class="hljs-keyword">int</span> j = i;                <span class="hljs-comment">// 从已经排序的序列最右边的开始比较，找到比其小的数</span>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; tmp &lt; arr[j - <span class="hljs-number">1</span>]) &#123;            arr[j] = arr[j - <span class="hljs-number">1</span>];            j--;        &#125;        <span class="hljs-comment">// 存在比其小的数，插入</span>        <span class="hljs-keyword">if</span> (j != i) &#123;            arr[j] = tmp;        &#125;    &#125;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><p>希尔排序（Shell Sort），是插入排序的一种更高效的改进版本，摒弃逐一元素对比而选用大跨步的间隔比较，使记录<strong>跳跃式接近它的排序位置</strong>。</p><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><p><strong>算法步骤</strong></p><ol><li>先取一个正整数步长 d1（d1 &lt; length），把全部记录分成 d1 个组，所有距离为 d1 的倍数的记录看成一组，然后在各组内进行插入排序</li><li>然后取 d2（d2 &lt; d1）</li><li>重复 1 和 2 两个步骤，直到 di = 1（i &gt;= 1）位置，即所有记录成为一个组，最后对这个组进行插入排序</li></ol><p><strong>动图演示</strong></p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201012143300.gif" alt="img"></p><p><strong>Java 代码实现</strong></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] shellSort(<span class="hljs-keyword">int</span>[] arr) &#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> len = arr.length;    <span class="hljs-keyword">int</span> group = len / <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (group &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = group; i &lt; len; i++) &#123;            <span class="hljs-comment">// j为分组后末尾的点 j-group为分组后起始的点</span>            <span class="hljs-comment">// 通过两者对应的值比较来排序</span>            <span class="hljs-keyword">int</span> j = i;            <span class="hljs-comment">// 待插入的点</span>            temp = arr[j];            <span class="hljs-comment">// 该组的后续元素比前面的小 需要移动小的元素到前面</span>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[j - group]) &#123;                <span class="hljs-comment">// 将分组后的元素向右按步长移动 直至j到达插入点或数组的起点</span>                <span class="hljs-keyword">while</span> (j - group &gt;= <span class="hljs-number">0</span> &amp;&amp; temp &lt; arr[j - group]) &#123;                    arr[j] = arr[j - group];                    j -= group;                &#125;                <span class="hljs-comment">// 此时索引j在数组的前面 将元素赋值给arr[j]</span>                arr[j] = temp;            &#125;        &#125;        group /= <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre><h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h2><p>归并排序（Merge Sort）是创建在归并操作上的一种有效的排序算法，效率为 O(n log n)，是采用<strong>分治法</strong>（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p><p><strong>算法步骤</strong></p><ol><li>把 n 个元素看成 n 个长度为 1 的有序子表</li><li>进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表</li><li>重复第 2 个步骤直到所有记录归并成一个长度为 n 的有序表为止</li></ol><p><strong>动图演示</strong></p><center>数组长度为偶数</center><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201012145026.gif" alt="even"></p><center>数组长度为奇数</center><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201012145054.gif" alt="odd"></p><p><strong>Java 代码实现</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 归并排序 - 递归分解 合并排序</span><span class="hljs-comment">*</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr   待排序数组</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> left  左边有序序列索引</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> right 右边有序序列索引</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> temp  中转数组</span><span class="hljs-comment">*/</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] mergeSort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp) &#123;    <span class="hljs-comment">// 递归终止条件 此时该部分数组被分为若干组小数组</span>    <span class="hljs-keyword">if</span> (left &gt;= right) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;    <span class="hljs-comment">// 向左递归分解</span>    mergeSort(arr, left, mid, temp);    <span class="hljs-comment">// 向右递归分解</span>    mergeSort(arr, mid + <span class="hljs-number">1</span>, right, temp);    <span class="hljs-comment">// 合并并返回</span>    <span class="hljs-keyword">return</span> merge(arr, left, mid, right, temp);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">* 归并排序 - 排序并合并过程</span><span class="hljs-comment">*</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr   待排序数组</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> left  左边有序序列的索引</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> mid   数组中间索引</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> right 右边有序序列索引</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> temp  中转数组</span><span class="hljs-comment">*/</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] merge(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp) &#123;    <span class="hljs-comment">// 左边有序序列的初始索引</span>    <span class="hljs-keyword">int</span> i = left;    <span class="hljs-comment">// 右边有序序列的初始索引</span>    <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;    <span class="hljs-comment">// 中转数组的当前索引</span>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 1. 先把左右两边(有序)数据填充到temp数组 直到左右其中一边处理完毕终止</span>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;        <span class="hljs-comment">// 如果左边的小于等于右边的元素</span>        <span class="hljs-comment">// 将左边的元素填充到temp数组中 反之亦然</span>        <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) &#123;            temp[t++] = arr[i++];        &#125; <span class="hljs-keyword">else</span> &#123;            temp[t++] = arr[j++];        &#125;    &#125;        <span class="hljs-comment">// 2. 把有剩余数据的一边数据全部填充到temp中</span>    <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;        temp[t++] = arr[i++];    &#125;    <span class="hljs-keyword">while</span> (j &lt;= right) &#123;        temp[t++] = arr[j++];    &#125;        <span class="hljs-comment">// 3. 增量地将temp数组有序的元素填充到原数组</span>    t = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> tempLeft = left;    <span class="hljs-comment">// 合并时的下标 可进入断点进行模拟</span>    <span class="hljs-comment">// 第1次合并时 tempLeft=0, right = l</span>    <span class="hljs-comment">// 第2次合并时 tempLeft=2, right = 3</span>    <span class="hljs-comment">// 第3次合并时 tempLeft=0, right = 3</span>    <span class="hljs-comment">// 最后一次合并, tempLeft=0, right=arr.length-1</span>    <span class="hljs-keyword">while</span> (tempLeft &lt;= right) &#123;        arr[tempLeft] = temp[t];        t++;        tempLeft++;    &#125;        <span class="hljs-keyword">return</span> arr;&#125;</code></pre><h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h2><p>快速排序（Quick sort）最早是由图灵奖得主东尼·霍尔提出的。在平均状况下，排序 n 个项目要 Ο(n * logn) 次比较。在最坏状况下则需要 Ο(n²) 次比较（但这种状况并不常见）。事实上，快速排序通常明显比其他 Ο(n * logn) 的算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序算法的<strong>基本思想</strong>是：通过一趟排序将待排序数据分割成独立的两部分，其中一部分的所有元素均比另一部分的元素小，然后分别对这两部分继续进行排序，重复上述步骤直到排序完成。</p><p><strong>算法步骤</strong></p><ol><li>在序列中选择一个元素作为“基准点” (<code>pivot</code>)</li><li>将所有小于“基准点”的元素都移到左边，所有大于“基准点”的元素都移到右边</li><li>对“基准点”左边和右边的两个子集，不断重复步骤 1 和 2，直到所有子集只剩下一个元素为止</li></ol><p><strong>动图演示</strong></p><center>数组长度为偶数</center><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201012163945.gif" alt="even"></p><center>数组长度为奇数</center><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201012164027.gif" alt="odd-1602491968355"></p><p><strong>Java 代码实现</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-comment">// 递归变量</span>    <span class="hljs-keyword">int</span> l = left;    <span class="hljs-keyword">int</span> r = right;        <span class="hljs-comment">// 设置基准值</span>    <span class="hljs-keyword">int</span> pivot = arr[(right + left) / <span class="hljs-number">2</span>];        <span class="hljs-comment">// 临时交换</span>    <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 1. 进行左右分组交换</span>    <span class="hljs-comment">// 从小到大排序</span>    <span class="hljs-comment">// 数组情况 [left(l)...[mid]...(r)right]</span>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;        <span class="hljs-comment">// 在中间元素的左边找大于它的值 放在右边</span>        <span class="hljs-keyword">while</span> (arr[l] &lt; pivot) &#123;            l += <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 在中间元素的右边找小于它的值 放在左边</span>        <span class="hljs-keyword">while</span> (arr[r] &gt; pivot) &#123;            r -= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 一趟排序结束 进入递归步骤</span>        <span class="hljs-keyword">if</span> (l &gt;= r) &#123;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-comment">// 左右元素交换</span>        temp = arr[l];        arr[l] = arr[r];        arr[r] = temp;        <span class="hljs-comment">// 交换完后 如果左边的值等于pivot 右边的往左移</span>        <span class="hljs-keyword">if</span> (arr[l] == pivot) &#123;            r--;        &#125;        <span class="hljs-comment">// 交换完后 如果右边的值等于pivot 左边的往右移</span>        <span class="hljs-keyword">if</span> (arr[r] == pivot) &#123;            l++;        &#125;    &#125;        <span class="hljs-comment">// 2. 进行左右递归</span>        <span class="hljs-comment">// 防止出现栈溢出</span>    <span class="hljs-keyword">if</span> (l == r) &#123;        l += <span class="hljs-number">1</span>;        r -= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 向左递归</span>    <span class="hljs-keyword">if</span> (left &lt; r) &#123;        <span class="hljs-comment">// 排序 [left,...,r][mid][l,...right]</span>        quickSort(arr, left, r);    &#125;    <span class="hljs-comment">// 向右边递归</span>    <span class="hljs-keyword">if</span> (l &lt; right) &#123;        <span class="hljs-comment">// 排序 [left,...,r][mid][l,...right]</span>        quickSort(arr, l, right);    &#125;&#125;</code></pre><h2 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p><strong>算法步骤</strong></p><ol><li>将无序序列<strong>构建成一个堆</strong>，根据升序选择大顶堆 此时<strong>堆顶元素为序列中最大的元素</strong></li><li>排序：将<strong>堆顶元素与末尾元素交换</strong>，将最大元素下沉到数组末尾</li><li>重新调整结构，使其满足堆定义</li><li>重复步骤2、3，直到整个序列有序</li></ol><p><strong>动图演示</strong></p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201012165158.gif" alt="img-20201012165158"></p><p><strong>Java 代码实现</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 堆排序(升序)</span><span class="hljs-comment">*</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr</span><span class="hljs-comment">*/</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] heapSort(<span class="hljs-keyword">int</span>[] arr) &#123;    <span class="hljs-comment">// 1. 将待排序序列调整为大顶堆 index为非叶子节点</span>    <span class="hljs-keyword">int</span> index = arr.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> len = arr.length;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        adjustHeap(arr, i, len);    &#125;    <span class="hljs-comment">// 2. 将堆顶元素与末尾元素交换，将最大元素沉到数组末端</span>    <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;    <span class="hljs-comment">// j 堆末尾元素下标； 0 堆顶元素下标</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = len - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; j--) &#123;        temp = arr[j];        arr[j] = arr[<span class="hljs-number">0</span>];        arr[<span class="hljs-number">0</span>] = temp;        <span class="hljs-comment">// 3. 重新调整结构，使其满足堆定义</span>        adjustHeap(arr, <span class="hljs-number">0</span>, j);    &#125;    <span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">* 功能：完成将以 index 对应的非叶子节点的树调整成大顶堆</span><span class="hljs-comment">* 举例：待排序序列为 &#123;4, 6, 8, 5, 9&#125;, 传入index=1，调整后变为 &#123;4, 9, 8, 5, 6&#125;</span><span class="hljs-comment">* 在此调用该方法，传入的index=0，调整后变为 &#123;9, 6, 8, 5, 4&#125;</span><span class="hljs-comment">*</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr   待排序序列</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> index 非叶子节点的下标</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> len   对多少个元素进行调整，调整完的元素不算在待排序列里</span><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> len)</span> </span>&#123;    <span class="hljs-comment">// 1. 取出当前元素的值 用于与子树元素比较</span>    <span class="hljs-keyword">int</span> temp = arr[index];    <span class="hljs-comment">// 开始调整</span>    <span class="hljs-comment">// k=index*2+1  index节点的左子节点，比较左右子节点(如果有)的元素</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; k &lt; len; k = k * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) &#123;                <span class="hljs-comment">// 2. 判断局部子树里节点较大，将k指向它</span>        <span class="hljs-comment">// 左子节点小于右子节点的值 让k指向右子节点(较大的数)</span>        <span class="hljs-keyword">if</span> (k + <span class="hljs-number">1</span> &lt; len &amp;&amp; arr[k] &lt; arr[k + <span class="hljs-number">1</span>]) &#123;            k++;        &#125;        <span class="hljs-comment">// 如果子节点大于父节点</span>        <span class="hljs-comment">// 3. 把大的值赋给父节点 并替换两者对应的下标 继续往下比较</span>        <span class="hljs-keyword">if</span> (arr[k] &gt; temp) &#123;            arr[index] = arr[k];            index = k;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 该局部树已比较完成 index是这三个节点中最大的</span>            <span class="hljs-keyword">break</span>;        &#125;    &#125;        <span class="hljs-comment">// 此时，完成将以index为父节点的子树的最大值放在堆顶(局部调整)</span>    <span class="hljs-comment">// 4. 此时的index指向的是比较后较小的元素 局部调整完成</span>    arr[index] = temp;&#125;</code></pre><h2 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h2><p>计数排序（Counting Sort）是一种稳定的线性时间排序算法。计数排序使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。</p><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p><strong>算法步骤</strong></p><ol><li>找出待排序的数组中最大（最小）的元素</li><li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项</li><li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）</li><li>反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1</li></ol><p><strong>动图演示</strong></p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201012170927.gif" alt="count"></p><p><strong>Java 代码实现</strong></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] countingSort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> maxValue) &#123;    <span class="hljs-keyword">int</span> bucketLen = maxValue + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[bucketLen];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;        bucket[value]++;    &#125;    <span class="hljs-keyword">int</span> sortedIndex = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; bucketLen; j++) &#123;        <span class="hljs-keyword">while</span> (bucket[j] &gt; <span class="hljs-number">0</span>) &#123;            arr[sortedIndex++] = j;            bucket[j]--;        &#125;    &#125;    <span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">* 获取数组中的最大值</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">int</span> maxValue = arr[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;        <span class="hljs-keyword">if</span> (maxValue &lt; value) &#123;            maxValue = value;        &#125;    &#125;    <span class="hljs-keyword">return</span> maxValue;&#125;</code></pre><h2 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h2><p>桶排序 (Bucket sort)是计数排序的升级版，它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p><p>桶排序的<strong>工作原理</strong>：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><p><strong>算法步骤</strong></p><ol><li>设置一个定量的数组当作空桶子</li><li>遍历数组，把数据放入对应的桶内</li><li>对每个非空的桶子进行排序</li><li>再把非空桶排好序的数据拼接起来</li></ol><p><strong>动图演示</strong></p><p><img src="https://blog.fiteen.top/2019/sorting-algorithm/bucket-sort.gif"></p><p><strong>Java 代码实现</strong></p><pre><code class="hljs java"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] bucketSort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> bucketSize) <span class="hljs-keyword">throws</span> Exception &#123;     <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) &#123;         <span class="hljs-keyword">return</span> arr;     &#125;     <span class="hljs-keyword">int</span> minValue = arr[<span class="hljs-number">0</span>];     <span class="hljs-keyword">int</span> maxValue = arr[<span class="hljs-number">0</span>];     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;         <span class="hljs-keyword">if</span> (value &lt; minValue) &#123;             minValue = value;         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &gt; maxValue) &#123;             maxValue = value;         &#125;     &#125;     <span class="hljs-keyword">int</span> bucketCount = (<span class="hljs-keyword">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="hljs-number">1</span>;     <span class="hljs-keyword">int</span>[][] buckets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[bucketCount][<span class="hljs-number">0</span>];     <span class="hljs-comment">// 利用映射函数将数据分配到各个桶中</span>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;         <span class="hljs-keyword">int</span> index = (<span class="hljs-keyword">int</span>) Math.floor((arr[i] - minValue) / bucketSize);         buckets[index] = arrAppend(buckets[index], arr[i]);     &#125;     <span class="hljs-keyword">int</span> arrIndex = <span class="hljs-number">0</span>;     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] bucket : buckets) &#123;         <span class="hljs-keyword">if</span> (bucket.length &lt;= <span class="hljs-number">0</span>) &#123;             <span class="hljs-keyword">continue</span>;         &#125;         <span class="hljs-comment">// 对每个桶进行排序，这里使用了插入排序</span>         bucket = insertSort.sort(bucket);         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : bucket) &#123;             arr[arrIndex++] = value;         &#125;     &#125;     <span class="hljs-keyword">return</span> arr; &#125;<span class="hljs-comment">/**</span><span class="hljs-comment">* 自动扩容，并保存数据</span><span class="hljs-comment">*</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> value</span><span class="hljs-comment">*/</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arrAppend(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value) &#123;    arr = Arrays.copyOf(arr, arr.length + <span class="hljs-number">1</span>);    arr[arr.length - <span class="hljs-number">1</span>] = value;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre><h2 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10. 基数排序"></a>10. 基数排序</h2><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数(关键字)切割成不同的数字，然后按每个位数分别比较。</p><p>对于关键字的选择，有最高位优先法（MSD 法）和<strong>最低位优先法</strong>（LSD 法）两种方式。</p><p>MSD 必须将序列先逐层分割成若干子序列，然后再对各子序列进行排序；而 LSD 进行排序时，不必分成子序列，对每个关键字都是整个序列参加排序。</p><p><strong>算法步骤</strong></p><p>以 <strong>LSD 法</strong>为例：</p><ol><li>将所有待比较数值（非负整数）统一为同样的数位长度，数位不足的数值前面补零</li><li>从最低位（个位）开始，依次进行一次排序</li><li>从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</li></ol><p><strong>动图演示 (以 LSD 为例)</strong></p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201012174249.gif" alt="radix_sort"></p><p><strong>Java 代码实现</strong></p><pre><code class="hljs java"><span class="hljs-comment">// LSD 实现</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> len = arr.length;    <span class="hljs-comment">// 定义一个二维数组 存储10个桶的一维数组</span>    <span class="hljs-keyword">int</span>[][] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>][len];    <span class="hljs-comment">// 定义一个桶元素容量数组 存储下标为键位的有效容量</span>    <span class="hljs-keyword">int</span>[] bucketElementCounts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];    <span class="hljs-comment">// 开始基数排序</span>    <span class="hljs-comment">// 1. 获取最高位的位数</span>    <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;        <span class="hljs-keyword">if</span> (arr[i] &gt; max) &#123;            max = arr[i];        &#125;    &#125;        <span class="hljs-comment">// 定义排序次数 (巧妙的方法)</span>    <span class="hljs-keyword">int</span> time = (max + <span class="hljs-string">&quot;&quot;</span>).length();    <span class="hljs-comment">// i为第几趟排序 初始为第一趟; n为位数 初始为个位</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, n = <span class="hljs-number">1</span>; i &lt;= time; i++, n *= <span class="hljs-number">10</span>) &#123;        <span class="hljs-comment">// 2. 遍历原数组 将其放入10个桶中</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;            <span class="hljs-keyword">int</span> digitOfElement = arr[j] / n % <span class="hljs-number">10</span>;            <span class="hljs-comment">// 元素放入键位为 digitOfElement 的桶中</span>            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];            <span class="hljs-comment">// 该桶有效容量+1</span>            bucketElementCounts[digitOfElement]++;        &#125;        <span class="hljs-comment">// 3. 将10个桶的元素按序放入原数组中</span>        <span class="hljs-comment">// bucketElementCounts.length为桶个数 即10</span>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;            <span class="hljs-comment">// 若该桶有元素 放入原数组</span>            <span class="hljs-comment">// bucketElementCounts[k]为桶元素个数</span>            <span class="hljs-keyword">if</span> (bucketElementCounts[k] != <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;                    arr[index++] = bucket[k][l];                &#125;            &#125;            <span class="hljs-comment">// !!重要!!</span>            <span class="hljs-comment">// 清空下标为k桶元素的容量 防止进行下次的排序栈溢出</span>            bucketElementCounts[k] = <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre><h4 id="基数排序-vs-计数排序-vs-桶排序"><a href="#基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="基数排序 vs 计数排序 vs 桶排序"></a>基数排序 vs 计数排序 vs 桶排序</h4><p>基数排序有两种方法：</p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的<strong>每位数字</strong>来分配桶，适用于<strong>非负整数</strong>间的排序，且最大值和最小值尽可能接近。</li><li>计数排序：每个桶只存储<strong>单一键值</strong>，适用于最大值和最小值尽可能相近的排序。</li><li>桶排序：每个桶存储<strong>一定范围</strong>的数值，适用于数据尽量分布均匀。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://visualgo.net/zh">算法可视化网站</a></li><li><a href="https://zoharyip.club/algorithm/sort-algorithms.html">各大排序算法的比较、研究与实现</a></li><li><a href="https://fishc.com.cn/">鱼C工作室</a></li><li><a href="https://blog.fiteen.top/2019/sorting-algorithm">动画详解十大经典排序算法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合框架整理</title>
    <link href="/2020/10/10/2020-10-10-Java-Collection-Interview/"/>
    <url>/2020/10/10/2020-10-10-Java-Collection-Interview/</url>
    
    <content type="html"><![CDATA[<center style='font-size: 18px; font-weight: bold;'>Java 集合框架一览图</center><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010143050.png" alt="image-20201010141215496"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近正在准备面试，借由此来复习一下 Java 集合类的基础知识及相关面试题，常学常新。</p><h2 id="集合-Collection"><a href="#集合-Collection" class="headerlink" title="集合 Collection"></a>集合 Collection</h2><blockquote><p><a href="https://segmentfault.com/a/1190000023856654">https://segmentfault.com/a/1190000023856654</a></p><p><a href="https://mp.weixin.qq.com/s/7WA1k31xmatsYTEfyMdLEQ">https://mp.weixin.qq.com/s/7WA1k31xmatsYTEfyMdLEQ</a></p><p><a href="https://segmentfault.com/a/1190000023081145">https://segmentfault.com/a/1190000023081145</a></p><p><a href="https://segmentfault.com/a/1190000023199039">https://segmentfault.com/a/1190000023199039</a></p><p><a href="https://segmentfault.com/a/1190000020014357">https://segmentfault.com/a/1190000020014357</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010235450.png" alt="image-20201010235448614"></p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h2 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射 Map"></a>映射 Map</h2><h2 id="工具类-Collections-amp-Arrays"><a href="#工具类-Collections-amp-Arrays" class="headerlink" title="工具类 Collections &amp; Arrays"></a>工具类 Collections &amp; Arrays</h2><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="1-Arraylist-与-LinkedList-区别"><a href="#1-Arraylist-与-LinkedList-区别" class="headerlink" title="1. Arraylist 与 LinkedList 区别"></a>1. Arraylist 与 LinkedList 区别</h3><p>可以从它们的底层数据结构、效率、开销进行阐述哈</p><ul><li>ArrayList是<strong>数组</strong>的数据结构，LinkedList是<strong>链表</strong>的数据结构。</li><li>随机访问的时候，ArrayList的效率比较高，因为LinkedList要移动指针，而ArrayList是基于索引(index)的数据结构，可以直接映射到。</li><li>插入、删除数据时，LinkedList的效率比较高，因为ArrayList删除数据时索引后的元素都需要移动。</li><li>LinkedList比ArrayList开销更大，因为LinkedList的节点除了存储数据，还需要存储引用。</li></ul><h3 id="2-Collections-和-Arrays-的-sort-实现原理"><a href="#2-Collections-和-Arrays-的-sort-实现原理" class="headerlink" title="2. Collections 和 Arrays 的 sort 实现原理"></a>2. Collections 和 Arrays 的 sort 实现原理</h3><p><strong>Collection.sort是对 <em>list</em> 进行排序</strong>，<strong>Arrays.sort 是对 <em>数组</em> 进行排序</strong>。</p><h4 id="Collections-sort底层实现"><a href="#Collections-sort底层实现" class="headerlink" title="Collections.sort底层实现"></a>Collections.sort底层实现</h4><p>Collections.sort方法调用了list.sort方法<br><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010152717.png"><br>list.sort方法调用了Arrays.sort的方法<br><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010152735.png"><br>因此，<strong>Collections.sort方法底层就是调用的Array.sort方法</strong></p><h4 id="Arrays-sort底层实现"><a href="#Arrays-sort底层实现" class="headerlink" title="Arrays.sort底层实现"></a>Arrays.sort底层实现</h4><p>Arrays的sort方法，如下：<br><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010161759.png"><br>如果比较器为null，进入sort（a）方法。如下：<br><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010162002.png"><br>因此，Arrays的sort方法底层就是：</p><ul><li>legacyMergeSort(a)，归并排序，</li><li>ComparableTimSort.sort()：即Timsort排序。</li></ul><h4 id="Timesort排序"><a href="#Timesort排序" class="headerlink" title="Timesort排序"></a>Timesort排序</h4><p>Timsort排序是结合了合并排序（merge.sort）和插入排序（insertion sort）而得出的排序方法；</p><p>1.当数组长度小于某个值，采用的是<strong>二分插入排序算法</strong>，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010162757.png"></p><ol start="2"><li>找到各个run，并入栈。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010162927.png"></p><ol start="3"><li>按规则合并run。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010162940.png"></p><h3 id="3-HashMap原理，java8做了什么改变"><a href="#3-HashMap原理，java8做了什么改变" class="headerlink" title="3. HashMap原理，java8做了什么改变"></a>3. HashMap原理，java8做了什么改变</h3><ul><li>HashMap是以键值对存储数据的集合容器</li><li>HashMap是非线性安全的。</li><li>HashMap底层数据结构：数组+(链表、红黑树)，jdk8之前是用数组+链表的方式实现，jdk8引进了红黑树</li><li>Hashmap数组的默认初始长度是16，<strong>key和value都允许null</strong>的存在</li><li>HashMap的内部实现数组是<strong>Node&lt;K,V&gt;数组</strong>，上面存放的是key-value键值对的节点。HashMap通过put和get方法存储和获取。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010162948.png" alt="img"></p><ul><li><p>jdk7的HashMap的put方法，<strong>首先计算key的hashcode值，定位到对应的数组索引</strong>，然后再在<strong>该索引的单向链表上进行循环遍历，用equals比较key是否存在</strong>，如果<strong>存在</strong>则用新的value覆盖原值，如果<strong>没有则头插法追加</strong>。</p></li><li><p>jdk8中HashMap的put方法：先判断Hashmap是否为空，<strong>为空就设置初始容量16(扩容操作)</strong> ，首先 <strong>计算出key的hash值(hash = h ^ (h&gt;&gt;&gt;16))</strong> ，再根据寻址算法 <strong>hash &amp; (n-1)</strong> 得到数组索引 <strong>i</strong> ，然后看table[i]是否为空，为空就直接插入，不为空判断<strong>当前位置的key和table[i]是否相同</strong>，相同就覆盖，不相同就查看table[i]是否是红黑树节点，如果是的话就用红黑树直接插入键值对，如果不是开始遍历链表插入，如果遇到重复值就覆盖，否则直接插入，如果链表长度大于8，转为红黑树结构，执行完成后，判断*<em>tableSize是否大于阈值 threshold(即 capacity * 装载因子)，大于就扩容，否则直接结束*</em>。</p><ul><li>计算 hashcode 与 数组索引 i 方法，其中 <strong>&gt;&gt;&gt; 表示右移后，高位的空位补零</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010162954.png" alt="image-20200908194529785"></p><ul><li>put方法 总体流程如下图</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010163054.png" alt="image-20200908193340642"></p><ul><li><p>Hashmap<strong>解决hash冲突</strong>，使用的是链地址法，即<strong>数组+链表的形式来解决</strong>。put执行首先判断table[i]位置，如果为空就直接插入，不为空判断和当前值是否相等，相等就覆盖，如果不相等的话，判断是否是红黑树节点，如果不是，就从table[i]位置开始遍历链表，相等覆盖，不相等插入。</p></li><li><p>HashMap的get方法就是计算出要<strong>获取元素的hash值</strong>，去对应位置获取即可。</p></li><li><p>HashMap的<strong>扩容机制</strong>，Hashmap的扩容中主要进行两步，第一步把数组长度变为原来的两倍，第二部把旧数组的元素重新计算hash插入到新数组中，jdk8时，不用重新计算hash，只用看看原来的hash值新增的一位是零还是1，如果是1这个元素在新数组中的位置，是原数组的位置加原数组长度，如果是零就插入到原数组中。扩容过程第二部一个非常重要的方法是transfer方法，采用头插法，把旧数组的元素插入到新数组中。</p><ul><li><strong>扩容机制</strong> ，threshold(即 capacity * 装载因子)，oldCap 为旧的 map 容量</li></ul><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010165232.jpg" alt="090821532570_0HashMap扩容原理_1" style="zoom: 80%;" /><ul><li>e.hash &amp; oldCap 迁移老数据到新map时采用 <strong>高低链算法</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010163237.png" alt="image-20200908221813030"></p></li><li><p>HashMap大小为什么是2的幂次方？<strong>效率高+空间分布均匀</strong></p></li></ul><p>有关于HashMap这些常量设计目的，也可以看我这篇文章：<br><a href="https://juejin.im/post/5d7195f9f265da03a6533942">面试加分项-HashMap源码中这些常量的设计目的</a></p><h3 id="4-List-和-Set，Map-的区别"><a href="#4-List-和-Set，Map-的区别" class="headerlink" title="4. List 和 Set，Map 的区别"></a>4. List 和 Set，Map 的区别</h3><ul><li>List 以索引来存取元素，有序的，元素是允许重复的，可以插入多个null。</li><li>Set 不能存放重复元素，无序的，只允许一个null</li><li>Map 保存键值对映射，映射关系可以一对一、多对一</li><li>List 有基于数组、链表实现两种方式</li><li>Set、Map 容器有基于哈希存储和红黑树两种方式实现</li><li>Set 基于 Map 实现，Set 里的元素值就是 Map的键值</li></ul><h3 id="5-poll-方法和-remove-方法的区别？"><a href="#5-poll-方法和-remove-方法的区别？" class="headerlink" title="5. poll()方法和 remove()方法的区别？"></a>5. poll()方法和 remove()方法的区别？</h3><p>Queue队列中，poll() 和 remove() 都是从队列中取出一个元素，在队列元素为空的情况下，<strong>remove() 方法会抛出异常，poll() 方法只会返回 null</strong> 。</p><p>看一下源码的解释吧：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * Retrieves and removes the head of this queue.  This method differs</span><span class="hljs-comment">    * from &#123;<span class="hljs-doctag">@link</span> #poll poll&#125; only in that it throws an exception if this</span><span class="hljs-comment">    * queue is empty.</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> the head of this queue</span><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> NoSuchElementException if this queue is empty</span><span class="hljs-comment">    */</span>   <span class="hljs-function">E <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;          <span class="hljs-comment">/**</span><span class="hljs-comment">    * Retrieves and removes the head of this queue,</span><span class="hljs-comment">    * or returns &#123;<span class="hljs-doctag">@code</span> null&#125; if this queue is empty.</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> the head of this queue, or &#123;<span class="hljs-doctag">@code</span> null&#125; if this queue is empty</span><span class="hljs-comment">    */</span>   <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;</code></pre><h3 id="6-HashMap，HashTable，ConcurrentHashMap-的共同点和区别"><a href="#6-HashMap，HashTable，ConcurrentHashMap-的共同点和区别" class="headerlink" title="6. HashMap，HashTable，ConcurrentHashMap 的共同点和区别"></a>6. HashMap，HashTable，ConcurrentHashMap 的共同点和区别</h3><ul><li>共同点：jdk 1.8 后，底层数据结构都一样，均由 <strong>数组+链表+红黑树</strong> 实现。</li></ul><p><strong>HashMap</strong></p><ul><li>可以存储null键和null值</li><li>线性不安全</li><li>初始容量为16，扩容每次都是2的n次幂</li><li>加载因子为0.75，当Map中元素总数超过Entry数组的0.75，触发扩容操作.</li><li>并发情况下，HashMap进行put操作会引起死循环(jdk1.7)，导致CPU利用率接近100%</li><li>HashMap是对Map接口的实现</li></ul><p><strong>HashTable</strong></p><ul><li>无论key还是value都不能为null</li><li>它是线性安全的，使用了<strong>synchronized关键字，效率低下</strong>，当一个线程占用时其他线程均不可put或get操作。</li><li>HashTable实现了Map接口和Dictionary抽象类</li><li><strong>Hashtable初始容量为11</strong></li></ul><p><strong>ConcurrentHashMap</strong></p><ul><li><strong>不能存储null键和值</strong></li><li>ConcurrentHashMap是线程安全的，并发控制<strong>使用 synchronized 和 CAS 来给 Node 上锁</strong>，而其他未上锁的节点不受影响。</li><li>ConcurrentHashMap使用锁分段技术确保线性安全</li><li>JDK8为何又放弃分段锁，是因为<strong>多个分段锁浪费内存空间</strong>，竞争同一个锁的概率非常小，分段锁反而会造成效率低。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010163246.png" alt="image-20200908222118187"></p><h3 id="7-写一段代码在遍历-ArrayList-时移除一个元素"><a href="#7-写一段代码在遍历-ArrayList-时移除一个元素" class="headerlink" title="7. 写一段代码在遍历 ArrayList 时移除一个元素"></a>7. 写一段代码在遍历 ArrayList 时移除一个元素</h3><p>因为foreach删除会导致快速失败问题，fori顺序遍历会导致重复元素没删除，所以正确解法如下：</p><p>第一种遍历，<strong>倒叙遍历删除</strong></p><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=list.size()-<span class="hljs-number">1</span>; i&gt;-<span class="hljs-number">1</span>; i--)&#123;  <span class="hljs-keyword">if</span>(list.get(i).equals(<span class="hljs-string">&quot;jay&quot;</span>))&#123;    list.remove(list.get(i));  &#125;&#125;</code></pre><p>第二种，迭代器删除</p><pre><code class="hljs java">Iterator itr = list.iterator();<span class="hljs-keyword">while</span>(itr.hasNext()) &#123;      <span class="hljs-keyword">if</span>(itr.next().equals(<span class="hljs-string">&quot;jay&quot;</span>) &#123;        itr.remove();      &#125;&#125;</code></pre><h3 id="8-Java中怎么打印数组？"><a href="#8-Java中怎么打印数组？" class="headerlink" title="8. Java中怎么打印数组？"></a>8. Java中怎么打印数组？</h3><p>数组是不能直接打印的哈，如下:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String[] jayArray = &#123;<span class="hljs-string">&quot;jay&quot;</span>, <span class="hljs-string">&quot;boy&quot;</span>&#125;;        System.out.println(jayArray);    &#125;&#125;<span class="hljs-comment">//output</span>[Ljava.lang.String;@<span class="hljs-number">1540e19d</span></code></pre><p>打印数组可以用流的方式 <strong>Strem.of().foreach()</strong> ，如下:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String[] jayArray = &#123;<span class="hljs-string">&quot;jay&quot;</span>, <span class="hljs-string">&quot;boy&quot;</span>&#125;;        Stream.of(jayArray).forEach(System.out::println);    &#125;&#125;<span class="hljs-comment">//output</span>jayboy</code></pre><p>打印数组，最优雅的方式可以用这个APi, <strong>Arrays.toString()</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String[] jayArray = &#123;<span class="hljs-string">&quot;jay&quot;</span>, <span class="hljs-string">&quot;boy&quot;</span>&#125;;        System.out.println(Arrays.toString(jayArray));    &#125;&#125;<span class="hljs-comment">//output</span>[jay, boy]</code></pre><h3 id="9-TreeMap底层？"><a href="#9-TreeMap底层？" class="headerlink" title="9. TreeMap底层？"></a>9. TreeMap底层？</h3><ul><li>TreeMap实现了 SortedMap 接口，它是有序的集合。</li><li>TreeMap<strong>底层数据结构</strong>是一个==<strong>红黑树</strong>==，每个key-value都作为一个红黑树的节点。</li><li>如果在调用TreeMap的构造函数时没有指定比较器，则<strong>根据key执行自然排序</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010163415.png"></p><h3 id="10-HashMap-的扩容过程"><a href="#10-HashMap-的扩容过程" class="headerlink" title="10. HashMap 的扩容过程"></a>10. HashMap 的扩容过程</h3><p>Hashmap的扩容：</p><ul><li><p>第一步把数组长度变为原来的两倍，</p></li><li><p>第二步把旧数组的元素重新计算hash插入到新数组中。</p></li><li><p>jdk1.8时，不用重新计算hash，只用看看原来的hash值新增的一位是零还是1，如果是1这个元素在新数组中的位置，是原数组的位置加原数组长度，如果是零就插入到原数组中。扩容过程第二步一个非常重要的方法是transfer方法，<strong>采用尾插法，把旧数组的元素插入到新数组中</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010163237.png" alt="image-20200908224119460"></p></li></ul><h3 id="11-HashSet是如何保证不重复的"><a href="#11-HashSet是如何保证不重复的" class="headerlink" title="11. HashSet是如何保证不重复的"></a>11. HashSet是如何保证不重复的</h3><p>可以看一下HashSet的add方法，元素E作为HashMap的key，我们都知道HashMap的可以是不允许重复的，哈哈。</p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;&#125;</code></pre><h3 id="12-HashMap-是线程安全的吗，为什么不是线程安全的？死循环问题？"><a href="#12-HashMap-是线程安全的吗，为什么不是线程安全的？死循环问题？" class="headerlink" title="12. HashMap 是线程安全的吗，为什么不是线程安全的？死循环问题？"></a>12. HashMap 是线程安全的吗，为什么不是线程安全的？死循环问题？</h3><p>不是线性安全的。</p><p>并发的情况下，扩容可能导致死循环问题。</p><h3 id="13-LinkedHashMap的应用，底层，原理"><a href="#13-LinkedHashMap的应用，底层，原理" class="headerlink" title="13. LinkedHashMap的应用，底层，原理"></a>13. LinkedHashMap的应用，底层，原理</h3><ul><li>LinkedHashMap维护着一个运行于所有条目的<strong>双重链接列表</strong>。此<strong>链接列表定义了迭代顺序</strong>，该迭代顺序可以是<strong>插入顺序（insert-order）或者是访问顺序</strong>，其中默认的迭代访问顺序就是插入顺序，即可以按插入的顺序遍历元素，这点和HashMap有很大的不同。</li><li><strong>LRU算法</strong>可以用LinkedHashMap实现。</li></ul><h3 id="14-哪些集合类是线程安全的？哪些不安全？"><a href="#14-哪些集合类是线程安全的？哪些不安全？" class="headerlink" title="14. 哪些集合类是线程安全的？哪些不安全？"></a>14. 哪些集合类是线程安全的？哪些不安全？</h3><p>线性安全的</p><ul><li>Vector：比Arraylist多了个同步化机制。</li><li>Hashtable：比Hashmap多了个线程安全。</li><li>ConcurrentHashMap:是一种高效但是线程安全的集合。</li><li>Stack：栈，也是线程安全的，继承于Vector。</li></ul><p>线性不安全的</p><ul><li>Hashmap</li><li>Arraylist</li><li>LinkedList</li><li>HashSet</li><li>TreeSet</li><li>TreeMap</li></ul><h3 id="15-ArrayList-和-Vector-的区别是什么？"><a href="#15-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="15. ArrayList 和 Vector 的区别是什么？"></a>15. ArrayList 和 Vector 的区别是什么？</h3><ul><li>Vector是线程安全的，ArrayList不是线程安全的。</li><li>ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。</li><li>Vector只要是关键性的操作，方法前面都加了synchronized关键字，来保证线程的安全性。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010163434.png"></p><h3 id="16-Collection与Collections的区别是什么？"><a href="#16-Collection与Collections的区别是什么？" class="headerlink" title="16. Collection与Collections的区别是什么？"></a>16. Collection与Collections的区别是什么？</h3><ul><li><strong>Collection<E>是Java集合框架中的基本接口</strong>，如List接口也是继承于它</li></ul><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>List&lt;E&gt; extends Collection&lt;E&gt; &#123;</code></pre><ul><li><strong>Collections是Java集合框架提供的一个工具类</strong>，其中包含了大量用于操作或返回集合的静态方法。如下：</li></ul><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> &lt;T <span class="hljs-keyword">extends</span> Comparable<span class="hljs-meta">&lt;?</span> super T&gt;&gt; <span class="hljs-keyword">void</span> sort(<span class="hljs-keyword">List</span>&lt;T&gt; <span class="hljs-keyword">list</span>) &#123;    <span class="hljs-keyword">list</span>.sort(<span class="hljs-literal">null</span>);&#125;</code></pre><h3 id="17-如何决定使用-HashMap-还是TreeMap？"><a href="#17-如何决定使用-HashMap-还是TreeMap？" class="headerlink" title="17. 如何决定使用 HashMap 还是TreeMap？"></a>17. 如何决定使用 HashMap 还是TreeMap？</h3><p>这个点，主要考察HashMap和TreeMap的区别。</p><p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序，默认是按key的升序排序，也可以指定排序的比较器。当用Iterator遍历TreeMap时，得到的记录是排过序的。</p><h3 id="18-如何实现数组和-List之间的转换？"><a href="#18-如何实现数组和-List之间的转换？" class="headerlink" title="18. 如何实现数组和 List之间的转换？"></a>18. 如何实现数组和 List之间的转换？</h3><h4 id="List-转-Array"><a href="#List-转-Array" class="headerlink" title="List 转 Array"></a>List 转 Array</h4><p><strong>List 转Array</strong>，必须使用集合的 <strong>toArray(T[] array)</strong> ，如下：</p><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();list.add(<span class="hljs-string">&quot;jay&quot;</span>);list.add(<span class="hljs-string">&quot;tianluo&quot;</span>);<span class="hljs-comment">// 使用泛型，无需显式类型转换</span>String[] array = list.toArray(<span class="hljs-keyword">new</span> String[list.size()]);System.out.println(array[<span class="hljs-number">0</span>]);</code></pre><p>如果直接使用 toArray 无参方法，返回值只能是 Object[] 类，强转其他类型可能有问题，demo如下：</p><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();list.add(<span class="hljs-string">&quot;jay&quot;</span>);list.add(<span class="hljs-string">&quot;tianluo&quot;</span>);String[] array = (String[]) list.toArray();System.out.println(array[<span class="hljs-number">0</span>]);</code></pre><p>运行结果：</p><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.String;at Test.main(Test.java:<span class="hljs-number">14</span>)</code></pre><h4 id="Array-转List"><a href="#Array-转List" class="headerlink" title="Array 转List"></a>Array 转List</h4><p>使用<strong>Arrays.asList() 把数组转换成集合</strong>时，其**底层仍是一个==数组==**！因此不能使用修改集合相关的方法，例如add方法，如下：</p><pre><code class="hljs java">String[] str = <span class="hljs-keyword">new</span> String[] &#123; <span class="hljs-string">&quot;jay&quot;</span>, <span class="hljs-string">&quot;tianluo&quot;</span> &#125;;List list = Arrays.asList(str);list.add(<span class="hljs-string">&quot;boy&quot;</span>);</code></pre><p>运行结果如下：</p><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.UnsupportedOperationExceptionat java.util.AbstractList.add(AbstractList.java:<span class="hljs-number">148</span>)at java.util.AbstractList.add(AbstractList.java:<span class="hljs-number">108</span>)at Test.main(Test.java:<span class="hljs-number">13</span>)</code></pre><p>因为 <strong>Arrays.asList</strong> 不是返回java.util.ArrayList,而是一个内部类ArrayList。<br><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010163448.png"></p><p>可以这样使用弥补这个缺点，例如 **new ArrayList&lt;&gt;(Arrays.asList(xxx))**：</p><pre><code class="hljs java"><span class="hljs-comment">//方式一：</span>ArrayList&lt; String&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(strArray.length);Collections.addAll(arrayList, strArray);<span class="hljs-comment">//方式二：</span>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(strArray)) ;</code></pre><h3 id="19-迭代器-Iterator-是什么？怎么用，有什么特点？"><a href="#19-迭代器-Iterator-是什么？怎么用，有什么特点？" class="headerlink" title="19. 迭代器 Iterator 是什么？怎么用，有什么特点？"></a>19. 迭代器 Iterator 是什么？怎么用，有什么特点？</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<span class="hljs-function">Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;</code></pre><p>方法如下：</p><pre><code class="hljs java">next() 方法获得集合中的下一个元素hasNext() 检查集合中是否还有元素remove() 方法将迭代器新返回的元素删除forEachRemaining(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; action) 方法，遍历所有元素</code></pre><p>Iterator 主要是用来遍历集合用的，它的特点是更加安全，能确保当前遍历的<strong>集合元素被更改</strong>的时候，就会<strong>抛出 ConcurrentModificationException 异常</strong>。</p><p>使用demo如下：</p><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();Iterator&lt;String&gt; it = list. iterator();<span class="hljs-keyword">while</span>(it. hasNext())&#123;  String obj = it. next();  System. out. println(obj);&#125;</code></pre><h3 id="20-Iterator-和-ListIterator-有什么区别？"><a href="#20-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="20. Iterator 和 ListIterator 有什么区别？"></a>20. Iterator 和 ListIterator 有什么区别？</h3><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010163454.png"></p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010163500.png"></p><ul><li>ListIterator 比 Iterator有更多的方法。</li><li><strong>ListIterator只能用于遍历List及其子类</strong>，Iterator可用来遍历所有集合，</li><li>ListIterator遍历可以是<strong>逆向的</strong>，因为有previous()和hasPrevious()方法，而Iterator不可以。</li><li>ListIterator有<strong>add()方法，可以向List添加对象</strong>，而Iterator却不能。</li><li>ListIterator可以<strong>定位当前的索引位置</strong>，因为有nextIndex()和previousIndex()方法，而Iterator不可以。</li><li>ListIterator可以<strong>实现对象的修改</strong>，set()方法可以实现。<strong>Iierator仅能遍历</strong>，不能修改哦。</li></ul><h3 id="21-怎么确保一个集合不能被修改？"><a href="#21-怎么确保一个集合不能被修改？" class="headerlink" title="21. 怎么确保一个集合不能被修改？"></a>21. 怎么确保一个集合不能被修改？</h3><p>很多朋友很可能想到用final关键字进行修饰，final修饰的这个成员变量，如果是基本数据类型，表示这个变量的值是不可改变的，如果是引用类型，则表示这个引用的地址值是不能改变的，但是这个引用所指向的对象里面的内容还是可以改变滴~验证一下，如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-comment">//final 修饰</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer, String&gt;();    &#123;        map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;jay&quot;</span>);        map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;tianluo&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;boy&quot;</span>);        System.out.println(map.get(<span class="hljs-number">1</span>));    &#125;&#125;</code></pre><p>运行结果如下:</p><pre><code class="hljs awk"><span class="hljs-regexp">//</span>可以洗发现，final修饰，集合还是会被修改呢boy</code></pre><p>嘻嘻，那么，到底怎么**==确保一个集合不能被修改==<strong>(集合不可变)呢，看以下这三个方法，即 ==**Collections.unmodifiable&lt;集合类型&gt;</strong>==</p><ul><li><strong>unmodifiableMap</strong></li><li><strong>unmodifiableList</strong></li><li><strong>unmodifiableSet</strong></li></ul><p>再看一下demo吧</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer, String&gt;();    &#123;        map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;jay&quot;</span>);        map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;tianluo&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        map = Collections.unmodifiableMap(map);        map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;boy&quot;</span>);        System.out.println(map.get(<span class="hljs-number">1</span>));    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="hljs java"><span class="hljs-comment">// 可以发现，unmodifiableMap确保集合不能修改啦，抛异常了</span>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.UnsupportedOperationExceptionat java.util.Collections$UnmodifiableMap.put(Collections.java:<span class="hljs-number">1457</span>)at Test.main(Test.java:<span class="hljs-number">14</span>)</code></pre><h3 id="22-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#22-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="22. 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>22. 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h3><h4 id="快速失败-普通-ArrayList"><a href="#快速失败-普通-ArrayList" class="headerlink" title="快速失败 (普通 ArrayList)"></a>快速失败 (普通 ArrayList)</h4><p>在用迭代器遍历一个集合对象时，如果遍历过程中对<strong>集合对象的内容进行了修改</strong>（增加、删除、修改），则会抛出Concurrent Modification Exception。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        list.add(<span class="hljs-number">1</span>);        list.add(<span class="hljs-number">2</span>);        Iterator iterator = list.iterator();        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            System.out.println(iterator.next());            list.add(<span class="hljs-number">3</span>);            System.out.println(list.size());        &#125;    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="hljs java"><span class="hljs-number">1</span>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.util.ConcurrentModificationException<span class="hljs-number">3</span>at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="hljs-number">909</span>)at java.util.ArrayList$Itr.next(ArrayList.java:<span class="hljs-number">859</span>)at Test.main(Test.java:<span class="hljs-number">12</span>)</code></pre><h4 id="安全失败-线程安全的-CopyOnWriteArrayList"><a href="#安全失败-线程安全的-CopyOnWriteArrayList" class="headerlink" title="安全失败 (线程安全的 CopyOnWriteArrayList)"></a>安全失败 (线程安全的 CopyOnWriteArrayList)</h4><p>采用安全失败机制的集合容器，<strong>在遍历时</strong>不是直接在集合内容上访问的，而是<strong>先复制原有集合内容，在拷贝的集合上进行遍历</strong>。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();        list.add(<span class="hljs-number">1</span>);        list.add(<span class="hljs-number">2</span>);        Iterator iterator = list.iterator();        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            System.out.println(iterator.next());            list.add(<span class="hljs-number">3</span>);            System.out.println(<span class="hljs-string">&quot;list size:&quot;</span>+list.size());        &#125;    &#125;&#125;</code></pre><p>运行结果：</p><pre><code class="hljs java"><span class="hljs-number">1</span>list size:<span class="hljs-number">3</span><span class="hljs-number">2</span>list size:<span class="hljs-number">4</span></code></pre><p>其实，在java.util.concurrent 并发包的集合，如 <strong>ConcurrentHashMap, CopyOnWriteArrayList等，默认为都是安全失败</strong>的。</p><h3 id="23-什么是Java优先级队列-Priority-Queue-？"><a href="#23-什么是Java优先级队列-Priority-Queue-？" class="headerlink" title="23. 什么是Java优先级队列(Priority Queue)？"></a>23. 什么是Java优先级队列(Priority Queue)？</h3><p>优先队列PriorityQueue是Queue接口的实现，可以对其中元素进行排序</p><ul><li>优先队列中元素默认排列顺序是<strong>升序排列</strong></li><li>但对于自己定义的类来说，需要自己定义比较器</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueue</span>&lt;<span class="hljs-title">E</span>&gt;</span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    ...     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; comparator;</code></pre><p>方法：</p><pre><code class="hljs java">peek()<span class="hljs-comment">//返回队首元素</span>poll()<span class="hljs-comment">//返回队首元素，队首元素出队列</span>add()<span class="hljs-comment">//添加元素</span>size()<span class="hljs-comment">//返回队列元素个数</span>isEmpty()<span class="hljs-comment">//判断队列是否为空，为空返回true,不空返回false</span></code></pre><p>特点：</p><ul><li>1.基于优先级堆 </li><li>2.不允许null值</li><li>3.线程不安全</li><li>4.出入队时间复杂度O(log(n))</li><li>5.调用remove()返回堆内最小值</li></ul><h3 id="24-JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。"><a href="#24-JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。" class="headerlink" title="24. JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。"></a>24. JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。</h3><p>jdk8 放弃了分段锁而是<strong>用了Node锁，减低锁的粒度，提高性能，并使用CAS操作来确保Node的一些操作的原子性，取代了锁</strong>。</p><p>可以跟面试官聊聊 <strong>悲观锁和CAS乐观锁 的区别</strong>，<strong>优缺点</strong>哈~</p><h3 id="25-阻塞队列的实现，ArrayBlockingQueue的底层实现？"><a href="#25-阻塞队列的实现，ArrayBlockingQueue的底层实现？" class="headerlink" title="25. 阻塞队列的实现，ArrayBlockingQueue的底层实现？"></a>25. 阻塞队列的实现，ArrayBlockingQueue的底层实现？</h3><p>ArrayBlockingQueue是数组实现的<strong>线程安全的有界的阻塞队列</strong>，继承自<strong>AbstractBlockingQueue</strong>,间接的实现了Queue接口和Collection接口。底层以数组的形式保存数据(实际上可看作一个<strong>循环数组</strong>)。常用的操作包括 add ,offer,put，remove,poll,take,peek。</p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010163508.png"></p><p>可以结合线程池跟面试官讲一下哦~</p><h3 id="26-Java-中的-LinkedList是单向链表还是双向链表？"><a href="#26-Java-中的-LinkedList是单向链表还是双向链表？" class="headerlink" title="26. Java 中的 LinkedList是单向链表还是双向链表？"></a>26. Java 中的 LinkedList是单向链表还是双向链表？</h3><p>哈哈，看源码吧，是双向链表</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    E item;    Node&lt;E&gt; next;    Node&lt;E&gt; prev;    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;        <span class="hljs-keyword">this</span>.item = element;        <span class="hljs-keyword">this</span>.next = next;        <span class="hljs-keyword">this</span>.prev = prev;    &#125;&#125;</code></pre><h3 id="27-说一说ArrayList-的扩容机制吧"><a href="#27-说一说ArrayList-的扩容机制吧" class="headerlink" title="27. 说一说ArrayList 的扩容机制吧"></a>27. 说一说ArrayList 的扩容机制吧</h3><p>ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将<strong>原有数组内容复制到新数组</strong>中去。</p><p><strong>ArrayList 的扩容流程图如下</strong></p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010163606.png" alt="image-20200908233859464" style="zoom: 80%;" /><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-comment">//扩容</span>    ensureCapacityInternal(size + <span class="hljs-number">1</span>); <span class="hljs-comment">// Increments modCount!!</span>    elementData[size++] = e;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">//如果传入的是个空数组则最小容量取默认容量与minCapacity之间的最大值</span>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);    &#125;    <span class="hljs-keyword">return</span> minCapacity;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    modCount++;    <span class="hljs-comment">// 如果最小需要空间比elementData的内存空间要大，则需要扩容</span>    <span class="hljs-comment">// overflow-conscious code</span>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)        grow(minCapacity);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;    <span class="hljs-comment">// 获取elementData数组的内存空间长度</span>    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;    <span class="hljs-comment">// 扩容至原来的1.5倍</span>    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-comment">//校验容量是否够</span>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)        newCapacity = minCapacity;    <span class="hljs-comment">//若预设值大于默认的最大值，检查是否溢出</span>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)        newCapacity = hugeCapacity(minCapacity);    <span class="hljs-comment">// 调用Arrays.copyOf方法将elementData数组指向新的内存空间</span>    <span class="hljs-comment">//并将elementData的数据复制到新的内存空间</span>    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</code></pre><h3 id="28-HashMap-的长度为什么是2的幂次方，以及其他常量定义的含义"><a href="#28-HashMap-的长度为什么是2的幂次方，以及其他常量定义的含义" class="headerlink" title="28. HashMap 的长度为什么是2的幂次方，以及其他常量定义的含义~"></a>28. HashMap 的长度为什么是2的幂次方，以及其他常量定义的含义~</h3><p>为了能让HashMap存取高效，数据分配均匀。</p><p>看着呢，以下等式相等，但是<strong>位移运算比取余效率高</strong>很多呢~</p><p>当 length 为 2的幂时，**<code>hash % length</code> 等价于<code>hash &amp; (length-1)</code>**。</p><p>可以看下我这篇文章哈~<br><a href="https://juejin.im/post/5d7195f9f265da03a6533942">面试加分项-HashMap源码中这些常量的设计目的</a></p><h3 id="29-ConcurrenHashMap-原理？1-8-中为什么要用红黑树？"><a href="#29-ConcurrenHashMap-原理？1-8-中为什么要用红黑树？" class="headerlink" title="29. ConcurrenHashMap 原理？1.8 中为什么要用红黑树？"></a>29. ConcurrenHashMap 原理？1.8 中为什么要用红黑树？</h3><p>聊到ConcurrenHashMap，需要跟面试官聊到安全性，分段锁segment，为什么放弃了分段锁，与及选择CAS，其实就是都是从效率和安全性触发，嘻嘻~</p><p>java8不是用红黑树来管理hashmap,而是在hash值相同的情况下(且重复数量大于8),用红黑树来管理数据。</p><p>红黑树相当于排序数据。可以自动的使用<strong>二分法进行定位数据，性能较高</strong>。</p><h3 id="30-ArrayList的默认大小"><a href="#30-ArrayList的默认大小" class="headerlink" title="30. ArrayList的默认大小"></a>30. ArrayList的默认大小</h3><p>ArrayList 的<strong>默认大小为 10</strong> 个元素</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">  * Default initial capacity.</span><span class="hljs-comment">  */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;</code></pre><h3 id="31-为何Collection不从Cloneable和Serializable接口继承？"><a href="#31-为何Collection不从Cloneable和Serializable接口继承？" class="headerlink" title="31. 为何Collection不从Cloneable和Serializable接口继承？"></a>31. 为何Collection不从Cloneable和Serializable接口继承？</h3><ul><li><p>Collection表示一个集合，包含了一组对象元素。如何维护它的元素对象是由具体实现来决定的。因为集合的具体形式多种多样，例如list允许重复，set则不允许。而<strong>克隆（clone）和序列化（serializable）只对于具体的实体，对象有意义</strong>，你不能说去把一个接口，抽象类克隆，序列化甚至反序列化。所以具体的collection实现类是否可以克隆，是否可以序列化应该由其自身决定，而不能由其超类强行赋予。 </p></li><li><p>如果collection继承了clone和serializable，那么所有的集合实现都会实现这两个接口，而如果某个实现它不需要被克隆，甚至不允许它序列化（<strong>序列化有风险</strong>），那么就与collection矛盾了。</p></li></ul><h3 id="32-Enumeration和Iterator接口的区别？"><a href="#32-Enumeration和Iterator接口的区别？" class="headerlink" title="32. Enumeration和Iterator接口的区别？"></a>32. Enumeration和Iterator接口的区别？</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Enumeration</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasMoreElements</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">nextElement</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">E <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;&#125;</code></pre><ul><li>函数接口不同</li><li><strong>Enumeration速度快</strong>，占用内存少，但是不是快速失败的，<strong>线程不安全</strong>。</li><li><strong>Iterator允许删除底层数据</strong>，枚举不允许</li><li><strong>Iterator安全性高</strong>，因为其他线程<strong>不能够修改</strong>正在被Iterator遍历的集合里面的对象。</li></ul><h3 id="33-我们如何对一组对象进行排序？"><a href="#33-我们如何对一组对象进行排序？" class="headerlink" title="33. 我们如何对一组对象进行排序？"></a>33. 我们如何对一组对象进行排序？</h3><p>可以用 <strong>Collections.sort（）+ Comparator.comparing（）</strong>，因为对对象排序，实际上是对<strong>对象的属性排序</strong>哈~</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> score;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> score)</span></span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.score = score;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> score;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> score)</span> </span>&#123;        <span class="hljs-keyword">this</span>.score = score;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student: &quot;</span> + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot; 分数：&quot;</span> + Integer.toString( <span class="hljs-keyword">this</span>.score );    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        studentList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-number">90</span>));        studentList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">100</span>));        studentList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">95</span>));        studentList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">95</span>));        Collections.sort(studentList, Comparator.comparing(Student::getScore).reversed().thenComparing(Student::getName));studentList.stream().forEach(p - &gt; System.out.println(p.toString()));    &#125;&#125;</code></pre><h3 id="34-当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它？"><a href="#34-当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它？" class="headerlink" title="34. 当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它？"></a>34. 当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它？</h3><p>这个跟之前那个不可变集合一样道理哈~</p><blockquote><p>在作为参数传递之前，使用==<strong>Collections.unmodifiableCollection</strong>==(Collection c)方法创建一个**==只读集合==**，这将确保改变集合的任何操作都会抛出UnsupportedOperationException。</p></blockquote><h3 id="35-说一下HashSet的实现原理？"><a href="#35-说一下HashSet的实现原理？" class="headerlink" title="35. 说一下HashSet的实现原理？"></a>35. 说一下HashSet的实现原理？</h3><ul><li><strong>不能保证元素的排列顺序</strong>，顺序有可能发生变化。</li><li>元素可以为null</li><li>hashse<strong>t保证元素不重复</strong>~ （这个面试官很可能会问什么原理，这个跟HashMap有关的哦）</li><li>HashSet，需要谈谈它俩hashcode()和equles()哦~（判断当前元素是否已添加，先检查hashcode再判断equals方法是否一致）</li><li>实际是基于HashMap实现的，HashSet 底层使用HashMap来保存所有元素的</li></ul><p>看看它的add方法吧~</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;&#125;</code></pre><h3 id="36-array数组-和-ArrayList-有何区别？"><a href="#36-array数组-和-ArrayList-有何区别？" class="headerlink" title="36. array数组 和 ArrayList 有何区别？"></a>36. array数组 和 ArrayList 有何区别？</h3><ul><li>定义一个 Array 时，<strong>必须指定数组的数据类型及数组长度</strong>，即数组中存放的元素个数固定并且类型相同。</li><li>ArrayList 是动态数组，<strong>长度动态可变，会自动扩容</strong>。不使用泛型的时候，可以添加不同类型元素。</li></ul><h3 id="37-为什么HashMap中String、Integer这样的包装类适合作为key？"><a href="#37-为什么HashMap中String、Integer这样的包装类适合作为key？" class="headerlink" title="37. 为什么HashMap中String、Integer这样的包装类适合作为key？"></a>37. 为什么HashMap中String、Integer这样的包装类适合作为key？</h3><p>String、Integer等包装类的特性<strong>能够保证Hash值的不可更改性和计算准确性</strong>，能够有效的减少Hash碰撞的几率~</p><p>因为</p><ul><li>它们都是<strong>final修饰的类，不可变性</strong>，保证key的不可更改性，不会存在获取hash值不同的情况~</li><li>它们<strong>内部已重写了equals()、hashCode()等方法</strong>，遵守了HashMap内部的规范</li></ul><h3 id="38-如果想用Object作为hashMap的Key？；"><a href="#38-如果想用Object作为hashMap的Key？；" class="headerlink" title="38. 如果想用Object作为hashMap的Key？；"></a>38. 如果想用Object作为hashMap的Key？；</h3><p><strong>重写hashCode()和equals()方法</strong>啦~ (这个答案来自互联网哈~)</p><blockquote><ul><li>重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li><li>重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性；</li></ul></blockquote><h3 id="39-讲讲红黑树的特点？"><a href="#39-讲讲红黑树的特点？" class="headerlink" title="39. 讲讲红黑树的特点？"></a>39. 讲讲红黑树的特点？</h3><p>​    <strong>根和NIL节点均为黑色，节点颜色非黑即红，红节点的子节点必为黑色，黑高。</strong></p><ul><li>每个节点或者是黑色，或者是红色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</li><li>如果一个节点是红色的，则它的<strong>子节点必须是黑色</strong>的。</li><li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。(黑高)</li></ul><h3 id="40-Java集合类框架的最佳实践有哪些？"><a href="#40-Java集合类框架的最佳实践有哪些？" class="headerlink" title="40. Java集合类框架的最佳实践有哪些？"></a>40. Java集合类框架的最佳实践有哪些？</h3><p>其实这些点，结合平时工作，代码总结讲出来，更容易吸引到面试官呢 (这个答案来自互联网哈~)</p><ul><li>1.根据应用需要正确选择要使用的集合类型对性能非常重要，比如：假如知道<strong>元素的大小是固定的，那么选用Array数组类型</strong>而不是ArrayList类型更为合适。</li><li>2.有些集合类型允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以<strong>指定初始容量</strong>来避免重新计算hash值或者扩容等。</li><li>3.为了类型安全、可读性和健壮性等原因总是要<strong>使用泛型</strong>。同时，使用泛型还可以避免运行时的 ClassCastException。</li><li>4.<strong>使用JDK提供的不变类(immutable class)作为Map的键key</strong>可以避免为我们自己的类实现hashCode()和equals()方法。</li><li>5.编程的时候接口优于实现</li><li>6.<strong>底层的集合实际上是空</strong>的情况下，返回为<strong>长度是0的集合或数组</strong>而不是null。</li></ul><h3 id="41-谈谈线程池阻塞队列吧"><a href="#41-谈谈线程池阻塞队列吧" class="headerlink" title="41.谈谈线程池阻塞队列吧~"></a>41.谈谈线程池阻塞队列吧~</h3><ul><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue</li><li>DelayQueue</li><li>PriorityBlockingQueue</li><li>SynchronousQueue</li></ul><p><strong>ArrayBlockingQueue：</strong> （有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</p><p><strong>LinkedBlockingQueue：</strong> （可设置容量队列）基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列</p><p><strong>DelayQueue：</strong>（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</p><p><strong>PriorityBlockingQueue：</strong>（优先级队列）是具有优先级的无界阻塞队列；</p><p><strong>SynchronousQueue：</strong>（同步队列）一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。<br>针对面试题：线程池都有哪几种工作队列？</p><p>我觉得，回答以上几种ArrayBlockingQueue，LinkedBlockingQueue，SynchronousQueue等，说出它们的特点，并结合使用到对应队列的常用线程池(如newFixedThreadPool线程池使用LinkedBlockingQueue)，进行展开阐述， 就可以啦。</p><p>有兴趣的朋友，可以看看我的<a href="%E6%8B%93%E5%B1%95%E6%96%87%E6%A1%A3%5C41_%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A3%E6%9E%90.md">这篇文章</a>哦~</p><p><a href="https://juejin.im/post/5d1882b1f265da1ba84aa676#heading-15">面试必备：Java线程池解析</a></p><h3 id="42-HashSet-和-TreeSet-有什么区别？"><a href="#42-HashSet-和-TreeSet-有什么区别？" class="headerlink" title="42. HashSet 和 TreeSet 有什么区别？"></a>42. HashSet 和 TreeSet 有什么区别？</h3><ul><li>Hashset 的底层是由**==哈希表==<strong>实现的，Treeset 底层是由==**红黑树</strong>==实现的。</li><li>HashSet中的元素没有顺序，TreeSet保存的元素**==有顺序性==**（实现Comparable接口）</li><li>HashSet的add()，remove()，contains()方法的时间复杂度是==<strong>O(1)</strong>==；TreeSet中，add()，remove()，contains()方法的时间复杂度是==<strong>O(logn)</strong>==</li></ul><h3 id="43-Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals"><a href="#43-Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals" class="headerlink" title="43. Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()?"></a>43. Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()?</h3><p>元素重复与否是<strong>使用equals()方法</strong>进行判断的，这个可以跟面试官说说==和equals()的区别，hashcode()和equals</p><h3 id="44-说出ArrayList-LinkedList的存储性能和特性"><a href="#44-说出ArrayList-LinkedList的存储性能和特性" class="headerlink" title="44. 说出ArrayList,LinkedList的存储性能和特性"></a>44. 说出ArrayList,LinkedList的存储性能和特性</h3><p>这道面试题，跟ArrayList,LinkedList，就是换汤不换药的~</p><ul><li>ArrayList,使用数组方式存储数据，查询时，ArrayList是基于索引(index)的数据结构，可以直接映射到，速度较快；但是插入数据需要移动数据，效率就比LinkedList慢一点~</li><li>LinkedList,使用双向链表实现存储,按索引数据需要进行前向或后向遍历，查询相对ArrayList慢一点；但是插入数据速度较快。</li><li>LinkedList比ArrayList开销更大，因为LinkedList的节点除了<strong>存储数据</strong>，还需要<strong>存储引用</strong>。</li></ul><h3 id="45-HashMap在JDK1-7和JDK1-8中有哪些不同？"><a href="#45-HashMap在JDK1-7和JDK1-8中有哪些不同？" class="headerlink" title="45. HashMap在JDK1.7和JDK1.8中有哪些不同？"></a>45. HashMap在JDK1.7和JDK1.8中有哪些不同？</h3><p>互联网上这个答案太详细啦（来源<a href="https://www.jianshu.com/p/939b8a672070">Java集合必会14问</a>）<br><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201010170050.png"></p><h3 id="46-ArrayList集合加入1万条数据，应该怎么提高效率"><a href="#46-ArrayList集合加入1万条数据，应该怎么提高效率" class="headerlink" title="46. ArrayList集合加入1万条数据，应该怎么提高效率"></a>46. ArrayList集合加入1万条数据，应该怎么提高效率</h3><blockquote><p>因为ArrayList的底层是数组实现,并且数组的默认值是10,如果插入10000条要不断的扩容,耗费时间,所以我们调用ArrayList的==指定容量==的构造器方法ArrayList(int size) 就可以实现不扩容,就提高了性能。</p></blockquote><h3 id="47-如何对Object的list排序"><a href="#47-如何对Object的list排序" class="headerlink" title="47. 如何对Object的list排序"></a>47. 如何对Object的list排序</h3><p>看例子吧，哈哈，这个跟对象排序也是一样的呢~</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;Person&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;jay&quot;</span>, <span class="hljs-number">18</span>));        list.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;tianLuo&quot;</span>, <span class="hljs-number">10</span>));        list.stream().forEach(p -&gt; System.out.println(p.getName()+<span class="hljs-string">&quot; &quot;</span>+p.getAge()));        <span class="hljs-comment">// 用comparing比较对象属性</span>        list.sort(Comparator.comparing(Person::getAge));        System.out.println(<span class="hljs-string">&quot;排序后&quot;</span>);        list.stream().forEach(p -&gt; System.out.print(p.getName()+<span class="hljs-string">&quot; &quot;</span>+p.getAge()+<span class="hljs-string">&quot; &quot;</span>));    &#125;&#125;</code></pre><h3 id="48-ArrayList-和-HashMap-的默认大小是多数？"><a href="#48-ArrayList-和-HashMap-的默认大小是多数？" class="headerlink" title="48. ArrayList 和 HashMap 的默认大小是多数？"></a>48. ArrayList 和 HashMap 的默认大小是多数？</h3><p>在 Java 7 中，<strong>ArrayList</strong> 的默认大小是 <strong>10 个元素</strong>，<strong>HashMap</strong> 的默认大小是<strong>16个元素</strong>（必须是2的幂）。</p><h3 id="49-有没有有顺序的Map实现类，如果有，他们是怎么保证有序的"><a href="#49-有没有有顺序的Map实现类，如果有，他们是怎么保证有序的" class="headerlink" title="49. 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的"></a>49. 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的</h3><ul><li>Hashmap和Hashtable 都不是有序的。</li><li><strong>TreeMap和LinkedHashmap都是有序的。</strong>（TreeMap默认是key升序，LinkedHashmap默认是数据插入顺序）</li><li>TreeMap是基于比较器Comparator来实现有序的。</li><li>LinkedHashmap是基于链表来实现数据插入有序的。</li></ul><h3 id="50-HashMap是怎么解决哈希冲突的"><a href="#50-HashMap是怎么解决哈希冲突的" class="headerlink" title="50. HashMap是怎么解决哈希冲突的"></a>50. HashMap是怎么解决哈希冲突的</h3><p>Hashmap解决hash冲突，使用的是<strong>链地址法</strong>，即<strong>数组+链表</strong>的形式来解决。put执行首先判断table[i]位置，如果为空就直接插入，不为空判断和当前值是否相等，相等就覆盖，如果不相等的话，判断是否是红黑树节点，如果不是，就从table[i]位置开始遍历链表，相等覆盖，不相等插入。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 学习笔记</title>
    <link href="/2020/10/07/2020-10-07-Study-Git-Note/"/>
    <url>/2020/10/07/2020-10-07-Study-Git-Note/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近发现了一个学习 Git 命令的好网站，是通过玩游戏的方式来可视化 git 命令的操作，方便上手掌握！</p><p>网址：<a href="https://git.mo.mk/">https://git.mo.mk/</a></p><p>参考攻略：<a href="https://www.cnblogs.com/WMCH/p/7876056.html">https://www.cnblogs.com/WMCH/p/7876056.html</a></p><h1 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h1><h2 id="1-Git基础篇"><a href="#1-Git基础篇" class="headerlink" title="1. Git基础篇"></a>1. Git基础篇</h2><p>循序渐进地介绍 Git 主要命令</p><h3 id="1-Git-Commit"><a href="#1-Git-Commit" class="headerlink" title="1. Git Commit"></a>1. Git Commit</h3><p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。</p><p>由于 Git 需要保存提交了的历史记录，因此大多数提交记录的上面都有父节点。</p><p><code>练习代码 &amp; 执行效果</code></p><pre><code class="hljs bash"><span class="hljs-comment"># 执行两次提交</span>git commitgit commit</code></pre><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201007224325.png" alt="image-20201007224322645"></p><h3 id="2-Git-Branch"><a href="#2-Git-Branch" class="headerlink" title="2. Git Branch"></a>2. Git Branch</h3><p>Git 的分支也非常轻量。它们只是简单地指向某个提交纪录，不会造成储存或内存上的开销，而是按逻辑分解工作到不同的分支上。</p><p><strong>早建分支！多用分支！</strong></p><p>将分支和提交记录结合起来，即基于这个提交以及它所有的父提交进行新的工作。</p><p><code>练习代码 &amp; 执行效果</code></p><pre><code class="hljs bash"><span class="hljs-comment"># 方式1</span>git checkout -b bugFix<span class="hljs-comment"># 创建并切换到 bugFix 分支</span><span class="hljs-comment"># 方式2</span>git branch bugFix <span class="hljs-comment"># 创建 bugFix 分支</span>git checkout bugFix <span class="hljs-comment"># 切换到 bugFix 分支</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201007231735.png" alt="Git Branch"></p><h3 id="3-Git-Merge"><a href="#3-Git-Merge" class="headerlink" title="3. Git Merge"></a>3. Git Merge</h3><p>Git 合并分支：将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。</p><p>Git Merge：在 Git 中合并两个分支时会产生一个有两个父节点的提交记录，具体流程如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201007234844.png" alt="image-20201007233914469"></p><p><code>练习代码 &amp; 执行效果</code></p><pre><code class="hljs bash">git checkout -b bugFix<span class="hljs-comment"># 创建并切换到 bugFix 分支</span>git commit<span class="hljs-comment"># 提交一次</span>git checkout master<span class="hljs-comment"># 切换到 master 分支</span>git commit<span class="hljs-comment"># 再提交一次</span>git merge bugFix<span class="hljs-comment"># 将 bugFix 分支合并到 master 分支</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201007234625.png" alt="image-20201007234623565"></p><h3 id="4-Git-Rebase"><a href="#4-Git-Rebase" class="headerlink" title="4. Git Rebase"></a>4. Git Rebase</h3><p>相较于 Merge 操作，Git Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p><p>其优势就是可以创造更线性的提交历史，让代码库的提交历史将会变得异常清晰。</p><p>具体流程，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201008000250.png" alt="image-20201007235434578"></p><p><code>练习代码 &amp; 执行效果</code></p><pre><code class="hljs bash">git checkout -b bugFix<span class="hljs-comment"># 创建并切换到 bugFix 分支</span>git commit<span class="hljs-comment"># 提交一次</span>git checkout master<span class="hljs-comment"># 切换到 master 分支</span>git commit<span class="hljs-comment"># 再提交一次</span>git checkout bugFix<span class="hljs-comment"># 切换到 bugFix 分支</span>git rebase master<span class="hljs-comment"># 将 bugFix 分支合并到 master 分支</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201007235900.png" alt="image-20201007235854007"></p><h2 id="2-Git高级篇"><a href="#2-Git高级篇" class="headerlink" title="2. Git高级篇"></a>2. Git高级篇</h2><p>来体验 Git 的超棒特性</p><h3 id="1-分离-HEAD"><a href="#1-分离-HEAD" class="headerlink" title="1. 分离 HEAD"></a>1. 分离 HEAD</h3><p><strong>HEAD</strong>： 指向<strong>当前分支上最近一次提交记录</strong>，大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的，即分离 HEAD。</p><p>更改 HEAD 指向</p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201008143329.png" alt="image-20201008143326919"></p><p>分离 HEAD 实例如下</p><p><code>练习代码 &amp; 执行效果</code></p><pre><code class="hljs bash">git checkout c1</code></pre><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201008142007.png" alt="image-20201008142005424"></p><h3 id="2-相对引用"><a href="#2-相对引用" class="headerlink" title="2. 相对引用"></a>2. 相对引用</h3><p>上一小结，我们学习到通过改变提交记录的哈希值来改变 HEAD 分支，而通过 <code>git log</code> 命令来获取提交记录的哈希值(可取前几位)，但通过指定提交记录哈希值的方式在 Git 中移动不太方便，因此 Git 加入了<strong>相对引用</strong>的方式来引用。</p><p><strong>相对引用有两种方式：</strong></p><ul><li>使用 <code>^</code> 向上移动 1 个提交记录</li><li>使用 <code>~&lt;num&gt;</code> 向上移动 n 个提交记录</li></ul><p><strong>相对引用(^) 示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201008150146.png" alt="image-20201008150144666"></p><p><strong>相对引用(~) 示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201008164048.png" alt="image-20201008164046820"></p><p><strong>强制修改分支位置</strong></p><p>使用 <code>-f</code> 让指定分支指向另一个提交，即修改分支位置。</p><p>让 master 分支强制指向 HEAD 的第 3 级父提交，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201008164816.png" alt="image-20201008164814954"></p><p>相对引用之(^)的<code>练习代码 &amp; 执行效果</code></p><pre><code class="hljs bash">git checkout bugFix^<span class="hljs-comment"># 提交到 bugFix 的父提交</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201008151014.png" alt="image-20201008151012184"></p><p>相对引用之(~)的<code>练习代码 &amp; 执行效果</code></p><pre><code class="hljs bash">git checkout HEAD~1<span class="hljs-comment"># HEAD指向C1</span>git branch -f master C6<span class="hljs-comment"># 分支master直接指向C6</span>git branch -f bugFix HEAD^<span class="hljs-comment"># 分支bugFix指向HEAD的上一级</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201008173214.png" alt="image-20201008173212358"></p><h3 id="3-撤销变更"><a href="#3-撤销变更" class="headerlink" title="3. 撤销变更"></a>3. 撤销变更</h3><p>撤销变更由底层部分（暂存区的独立文件或者片段）和<strong>上层部分</strong>（变更到底是通过<strong>哪种方式被撤销</strong>的）组成。我们这个应用主要关注的是后者。</p><p>两种方法用来撤销变更，分别是 <code>git reset</code>，还有就是 <code>git revert</code>。</p><ul><li><strong>git reset</strong>：通过把分支记录回退几个提交记录来实现撤销改动，原来指向的提交记录就跟从来没有提交过一样。（仅本地使用）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201008185948.png" alt="image-20201008185946102"></p><ul><li><p><strong>git revert</strong>：git reset 是无法更改远程分支的，为了撤销更改并<strong>分享</strong>给别人，Git 引入了更改机制，推送到远程分支，实现撤销上一个提交记录。</p><p>如下图，<strong>C1 的状态与 C2’ 是相同的</strong></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201008190215.png" alt="image-20201008190213601"></p><p><code>练习代码 &amp; 执行效果</code></p><pre><code class="hljs bash">git reset <span class="hljs-built_in">local</span>^<span class="hljs-comment"># 撤销本地分支(还原到上一个提交分支)</span>git checkout pushed<span class="hljs-comment"># 先切换到远程分支</span>git revert pushed<span class="hljs-comment"># 撤销远程分支(向远程分支推送更改的C2&#x27;, 状态与C1一样)</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201008201908.png" alt="image-20201008201907199"></p><hr><p>​        到这里，我们已经学习了 Git 的基础知识 —— <strong>提交、分支以及在提交树上移动</strong>。 这些概念涵盖了 Git 90% 的功能，同样也足够满足开发者的日常需求，剩余的 10%的是<strong>整理提交记录</strong>， 在处理复杂的工作流时(或者当你陷入困惑时）可能就显示尤为重要了。</p><h2 id="3-移动提交记录"><a href="#3-移动提交记录" class="headerlink" title="3. 移动提交记录"></a>3. 移动提交记录</h2><p>自由修改提交树</p><h3 id="1-Git-Cherry-pick"><a href="#1-Git-Cherry-pick" class="headerlink" title="1. Git Cherry-pick"></a>1. Git Cherry-pick</h3><p>Cherry-pick 能将<strong>一些提交复制到当前所在的位置（<code>HEAD</code>）的下面</strong>，命令格式为 <code>git cherry-pick &lt;提交号&gt;...</code>，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201008205915.png" alt="image-20201008205807863"></p><p><code>练习代码 &amp; 执行效果</code></p><pre><code class="hljs bash">git cherry-pick C3 C4 C7<span class="hljs-comment"># 把&lt;提交号&gt;抓过来放到当前分支下</span></code></pre><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201008210545.png" alt="image-20201008210521787" style="zoom:90%;" /><h3 id="2-图形交互式的-rebase"><a href="#2-图形交互式的-rebase" class="headerlink" title="2. 图形交互式的 rebase"></a>2. 图形交互式的 rebase</h3><p>当知道提交记录的<strong>哈希值</strong>时, 用 <strong>cherry-pick</strong> 再好不过了，而若不清楚哈希值时，采用<strong>图形交互式的 rebase</strong> 则是最好的方法。</p><p>交互式 rebase 指的是使用带参数 <code>--interactive</code> 的 rebase 命令, 简写为 <code>-i</code>，命令格式为 <code>git rebase -i HEAD~&lt;num&gt;</code>。</p><p>Git 会打开一个 UI 界面，并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p><p>当 rebase UI界面打开时, 你能做3件事：</p><ul><li>调整提交记录的顺序</li><li>删除你不想要的提交 (通过切换 <code>pick</code> 的状态完成，关闭即代表不提交该记录)</li><li>合并提交 (多个提交记录合并成一个)</li></ul><p><code>练习代码 &amp; 执行效果</code></p><pre><code class="hljs bash">git rebase -i HEAD~4</code></pre><p>Rebase UI 界面</p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201008212326.png" alt="image-20201008212245262"></p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201008212336.png" alt="image-20201008212254864"></p><h2 id="4-杂项"><a href="#4-杂项" class="headerlink" title="4. 杂项"></a>4. 杂项</h2><p>Git 技术、技巧与贴士大集合</p><h3 id="1-只取一个提交记录"><a href="#1-只取一个提交记录" class="headerlink" title="1. 只取一个提交记录"></a>1. 只取一个提交记录</h3><p><strong>本地栈式提交</strong>，在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，这个过程中顺带在代码中加了一些调试命令和打印语句(在各自的提交记录里)，Bug 解决完后就打算把 <code>bugFix</code> 分支里的工作合并回 <code>master</code> 分支了，但<strong>不想将调试语句和打印语句也一并提交</strong>。</p><p><code>练习代码 &amp; 执行效果</code></p><pre><code class="hljs bash">git rebase -i C2 C3<span class="hljs-comment"># 将C2,C3分支先挂起，另做处理</span>git checkout master<span class="hljs-comment"># 切换到master分支</span>git merge bugFix<span class="hljs-comment"># 将bugFix分支与master分支合并</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201008231357.png" alt="image-20201008231035992"></p><h3 id="2-提交的技巧-1"><a href="#2-提交的技巧-1" class="headerlink" title="2. 提交的技巧 #1"></a>2. 提交的技巧 #1</h3><p>使用场景：之前在 A 分支上进行了一次提交，然后又基于它创建了 <code>C1</code> 分支，然后又提交了一次，而此时你想<strong>对某个以前的提交记录进行修改</strong>。</p><p>具体操作可分为四个步骤：</p><ul><li>先用 <strong>git rebase -i</strong> 将提交<strong>重新排序</strong>，然后把我们想要修改的提交记录挪到最前</li><li>然后用 <strong>git commit –amend</strong> 来做一些小修改后重新提交</li><li>接着再用 <strong>git rebase -i</strong> 来还原提交记录的顺序</li><li>最后我们<strong>把 master 移到最新</strong>，就大功告成啦！</li></ul><p><code>练习代码 &amp; 执行效果</code></p><pre><code class="hljs bash">git rebase -i HEAD~2 <span class="hljs-comment"># 调整c2c3，得到c3&#x27; c2&#x27;</span>git commit --amend <span class="hljs-comment"># 修改c2&#x27;后重新提交，得到c2&#x27;&#x27;</span>git rebase -i HEAD~2 <span class="hljs-comment"># 调整c2&#x27;&#x27; c3&#x27;，得到c2&#x27;&#x27;&#x27; c3&#x27;&#x27;</span>git checkout master<span class="hljs-comment"># 切换到master分支</span>git merge caption <span class="hljs-comment"># caption指向c3&#x27;&#x27;，合并到master</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201008235222.png" alt="image-20201008235222"></p><h3 id="3-提交的技巧-2"><a href="#3-提交的技巧-2" class="headerlink" title="3. 提交的技巧 #2"></a>3. 提交的技巧 #2</h3><p>使用 <strong>cherry-pick</strong> 实现上述操作的相同效果，而且更便捷！</p><p>操作演示</p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201009095433.png" alt="image-20201009095425126"></p><p><code>练习代码 &amp; 执行效果</code></p><pre><code class="hljs bash">git checkout master<span class="hljs-comment"># 先切换到master分支</span>git cherry-pick C2<span class="hljs-comment"># 把C2转到master分支下，得到C2&#x27;</span>git commit --amend<span class="hljs-comment"># 重新提交C2&#x27;,得到C2&#x27;&#x27;</span>git cherry-pick C3<span class="hljs-comment"># 把C3转到master分支(C2&#x27;&#x27;)下，得到C3&#x27;</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201009095938.png" alt="image-20201009095936449"></p><h3 id="4-Git-Tag"><a href="#4-Git-Tag" class="headerlink" title="4. Git Tag"></a>4. Git Tag</h3><p>不难得出，分支的缺点主要是<strong>易被人为移动、改变</strong>，而且大部分分支还只是临时的，并且还一直在变。</p><p>而 <strong>标签</strong> 可以 <strong><em>永远</em> 指向某个提交记录的标识</strong>，它就像是提交树上的一个锚点，标识了某个特定的位置。</p><p>用途也很广，例如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性等。</p><p>命名语法为 <code>git tag &lt;标签名&gt; &lt;commit号&gt;</code>，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201009103006.png" alt="image-20201009102800288"></p><p><code>练习代码 &amp; 执行效果</code></p><pre><code class="hljs bash">git tag v0 C1<span class="hljs-comment"># 给C1添加标签v0</span>git tag v1 C2<span class="hljs-comment"># 给C2添加标签v1</span>git checkout C2<span class="hljs-comment"># 当前HEAD指向C2</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201009103455.png" alt="git tag"></p><h3 id="5-Git-Describe"><a href="#5-Git-Describe" class="headerlink" title="5. Git Describe"></a>5. Git Describe</h3><p><strong>Git Describe</strong>：用来<strong>描述</strong>离你最近的标签(锚点)，能帮你在提交历史中移动了多次以后找到方向。</p><p>命令语法是<code>git describe &lt;ref&gt;</code>，<code>&lt;ref&gt;</code> 可以是任何能<strong>被 Git 识别成提交记录的引用</strong>，Git 默认会以你目前所检出的位置<strong>（<code>HEAD</code>）</strong>。</p><p>输出的结果是 <code>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</code>，其中</p><ul><li><p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签</p></li><li><p><code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录</p></li><li><p><code>hash</code> 表示的是提交记录哈希值的前几位</p></li></ul><h1 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h1><h2 id="Git-远程仓库-Push-amp-Pull-及高级操作"><a href="#Git-远程仓库-Push-amp-Pull-及高级操作" class="headerlink" title="Git 远程仓库(Push &amp; Pull)及高级操作"></a>Git 远程仓库(Push &amp; Pull)及高级操作</h2><p>是时候分享你的代码了，让编码变得社交化吧</p><h3 id="1-Git-Clone-与-远程分支"><a href="#1-Git-Clone-与-远程分支" class="headerlink" title="1. Git Clone 与 远程分支"></a>1. Git Clone 与 远程分支</h3><p><code>git clone</code> 命令在真实的环境下的作用是在<strong>本地</strong>创建一个远程仓库的拷贝，命令语法为<code>git clone &lt;url&gt;</code>。</p><p>通过 <code>git clone</code>，我们在本地的仓库多了一个名为 <code>o/master</code> 的分支, 这种类型的分支就叫<strong>远程</strong>分支。</p><p>远程分支反映了远程仓库在你<strong>最后一次和它通信时的状态</strong>，有助于理解本地的工作与公共工作的差别。</p><p>远程分支的命名规范是 <code>&lt;remote name&gt;/&lt;branch name&gt;</code>，因此 <code>o/master</code> 分支中，分支名为 <code>master</code>，远程仓库的名称为 <code>origin</code>(为了简化用’o’代替)。</p><h3 id="2-Git-Fetch"><a href="#2-Git-Fetch" class="headerlink" title="2. Git Fetch"></a>2. Git Fetch</h3><p>Git 远程仓库相当的操作实际可以归纳为两点：<strong>向远程仓库传输数据</strong>(git push) 以及<strong>从远程仓库获取数据</strong>(git fetch)。</p><p><code>git fetch</code> 完成了仅有的但是很<strong>重要的两步</strong>:</p><ul><li>从远程仓库下载本地仓库中缺失的提交记录</li><li>更新远程分支指针(如 <code>o/master</code>)</li></ul><p><code>git fetch</code> 将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态，通常通过互联网（使用 <code>http://</code> 或 <code>git://</code> 协议) 与远程仓库通信。</p><p><code>git fetch</code> 只是执行单纯的下载操作，<strong>不会</strong>改变你本地仓库的状态，<strong>不会</strong>更新你的 <code>master</code> 分支，也<strong>不会</strong>修改你磁盘上的文件。</p><p><strong>git fetch 示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201009123552.png"></p><h3 id="3-Git-Pull"><a href="#3-Git-Pull" class="headerlink" title="3. Git Pull"></a>3. Git Pull</h3><p>Git Pull 实际上执行了两个操作， <strong>先抓取更新(git fetch)，再合并到本地分支(git <u>merge/base/cherry-pick</u> o/master)</strong> 。</p><p>先来看看 <code>fetch</code>、<code>merge</code> 依次执行的效果</p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201009124552.png" alt="image-20201009124542415"></p><p>使用 <code>git pull</code> 的效果</p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201009124552.png"></p><p>结论： <strong><code>git pull</code> 就是 git fetch 和 git merge <just-fetched-branch> 的缩写！</strong></p><h3 id="4-Git-Push"><a href="#4-Git-Push" class="headerlink" title="4. Git Push"></a>4. Git Push</h3><p><code>git push</code> 即<strong>向远程仓库传输数据</strong>，负责将<strong>本地的</strong>变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。</p><p>命令语法为：<code>git push &lt;remote&gt; &lt;place&gt;</code>。</p><p>例如：<code>git push origin master</code> 翻译过来是：切到本地仓库中的“master”分支，获取所有的提交，再到远程仓库“origin”中找到“master”分支，将远程仓库中没有的提交记录都添加上去。</p><p>其中 <code>&lt;place&gt;</code>可以划分为 <code>&lt;source&gt;:&lt;destination&gt;</code>，同时指定 <strong>源地址</strong> 和 <strong>目的地(若不存在则新建该分支)</strong> 。</p><p><strong>git push 示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201009125524.png" alt="image-20201009125523139"></p><p><strong>git push <remote> <place> 示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201009132449.png" alt="image-20201009132447363"></p><p><strong>git push origin <code>&lt;source&gt;:&lt;destination&gt;</code> 示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201009133122.png" alt="image-20201009133117183"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>分享其他不错的 Git 学习网站</p><ul><li><a href="https://try.github.io/">https://try.github.io</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 常用命令</title>
    <link href="/2020/10/05/2020-10-05-Git-Common-Commands/"/>
    <url>/2020/10/05/2020-10-05-Git-Common-Commands/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201007111524.png" alt="Git常用命令"></p><h1 id="Git-命令速查"><a href="#Git-命令速查" class="headerlink" title="Git 命令速查"></a>Git 命令速查</h1><h2 id="1-创建版本库"><a href="#1-创建版本库" class="headerlink" title="1. 创建版本库"></a>1. 创建版本库</h2><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> &lt;url&gt;<span class="hljs-comment"># 克隆远程版本库</span>git init<span class="hljs-comment"># 初始化本地版本库</span></code></pre><h2 id="2-修改与提交"><a href="#2-修改与提交" class="headerlink" title="2. 修改与提交"></a>2. 修改与提交</h2><p>一般都不推荐使用 <code>git commit -a</code> ，还是推荐先 <code>git add </code> 再 <code>git commit</code>。</p><pre><code class="hljs bash">git status                       <span class="hljs-comment"># 查看状态</span>git diff                         <span class="hljs-comment"># 查看变更内容</span>git add .                        <span class="hljs-comment"># 跟踪所有改动过的文件</span>git add &lt;file&gt;                   <span class="hljs-comment"># 跟踪指定的文件</span>git mv &lt;old&gt; &lt;new&gt;               <span class="hljs-comment"># 文件改名</span>git rm &lt;file&gt;                   <span class="hljs-comment"># 删除文件</span>git rm --cached&lt;file&gt;            <span class="hljs-comment"># 停止跟踪文件但不删除</span>git commit -m <span class="hljs-string">&quot;本次提交说明&quot;</span>   <span class="hljs-comment"># 提交所有更新过的文件</span>git commit --amend -m <span class="hljs-string">&quot;本次提交说明&quot;</span>  <span class="hljs-comment"># 重新提交 (适用于提交后错误的文件/信息后的情况)</span></code></pre><h2 id="3-查看提交历史"><a href="#3-查看提交历史" class="headerlink" title="3. 查看提交历史"></a>3. 查看提交历史</h2><pre><code class="hljs bash">git <span class="hljs-built_in">log</span>                    <span class="hljs-comment"># 查看提交历史</span>git <span class="hljs-built_in">log</span> -p &lt;file&gt;          <span class="hljs-comment"># 查看指定文件的提交历史</span>git blame &lt;file&gt;           <span class="hljs-comment"># 以列表方式查看指定文件的提交历史</span></code></pre><h2 id="4-撤销操作"><a href="#4-撤销操作" class="headerlink" title="4. 撤销操作"></a>4. 撤销操作</h2><pre><code class="hljs bash">git reset --hard HEAD      <span class="hljs-comment"># 撤销工作目录中所有未提交文件的修改内容</span>git checkout HEAD &lt;file&gt;   <span class="hljs-comment"># 撤销指定的未提交文件的修改内容</span>git revert &lt;commit&gt;        <span class="hljs-comment"># 撤销指定的提交</span>git <span class="hljs-built_in">log</span> --before=<span class="hljs-string">&quot;1 days&quot;</span>  <span class="hljs-comment"># 退回到之前1天的版本</span></code></pre><h2 id="5-分支与标签"><a href="#5-分支与标签" class="headerlink" title="5. 分支与标签"></a>5. 分支与标签</h2><pre><code class="hljs bash">git branch                   <span class="hljs-comment"># 显示所有本地分支</span>git branch &lt;new-branch&gt;      <span class="hljs-comment"># 创建新分支</span>git checkout &lt;branch/tag&gt;    <span class="hljs-comment"># 切换到指定分支或标签</span>git branch -b &lt;new-branch&gt;   <span class="hljs-comment"># 创建并切换到新分支</span>git branch -d &lt;branch&gt;       <span class="hljs-comment"># 删除本地分支</span>git tag                      <span class="hljs-comment"># 列出所有本地标签</span>git tag &lt;tag name&gt;           <span class="hljs-comment"># 基于最新提交创建标签</span>git tag -d &lt;tag name&gt;        <span class="hljs-comment"># 删除标签</span></code></pre><h2 id="6-合并与衍合"><a href="#6-合并与衍合" class="headerlink" title="6. 合并与衍合"></a>6. 合并与衍合</h2><pre><code class="hljs bash">git merge &lt;branch&gt;        <span class="hljs-comment"># 合并指定分支到当前分支</span>git rebase &lt;branch&gt;       <span class="hljs-comment"># 衍合指定分支到当前分支</span></code></pre><h2 id="7-远程操作"><a href="#7-远程操作" class="headerlink" title="7. 远程操作"></a>7. 远程操作</h2><pre><code class="hljs bash">git remote -v                         <span class="hljs-comment"># 查看远程版本库信息</span>git remote show &lt;remote&gt;              <span class="hljs-comment"># 查看指定远程版本库信息</span>git remote add &lt;remote&gt; &lt;url&gt;         <span class="hljs-comment"># 添加远程版本库</span>git remote set-url origin &lt;url&gt;  <span class="hljs-comment"># 重设远程版本库地址</span>git fetch &lt;remote&gt;                    <span class="hljs-comment"># 从远程库获取代码</span>git pull &lt;remote&gt; &lt;branch&gt;            <span class="hljs-comment"># 下载代码及快速合并</span>git push &lt;remote&gt; &lt;branch&gt;            <span class="hljs-comment"># 上传代码及快速合并</span>git push &lt;remote&gt; :&lt;branch/tag-name&gt;  <span class="hljs-comment"># 删除远程分支或标签</span>git push --tags                       <span class="hljs-comment"># 上传所有标签</span>git push -f origin &lt;branch&gt;  <span class="hljs-comment"># 强制推送到远程分支(分支回退到某次提交后的操作)</span></code></pre><h2 id="附录：速查表"><a href="#附录：速查表" class="headerlink" title="附录：速查表"></a>附录：速查表</h2><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>mkdir ‘xxx’</td><td>创建一个空目录 (xxx 指目录名)</td></tr><tr><td>pwd</td><td>显示当前目录的路径</td></tr><tr><td>git init</td><td>把当前的目录变成可以管理的 git 仓库，生成隐藏. git 文件</td></tr><tr><td>git add ‘xxx’</td><td>把 xxx 文件添加到暂存区去</td></tr><tr><td>git commit –m ‘xxx’</td><td>xxx 为提交文件的是注释</td></tr><tr><td>git status</td><td>查看仓库状态</td></tr><tr><td>git diff ‘xxx’</td><td>查看 ‘xxx’ 文件修改了哪些内容</td></tr><tr><td><strong>git log</strong></td><td><strong>查看历史记录</strong></td></tr><tr><td><strong>git reset –hard HEAD^</strong></td><td><strong>回退到上一个版本</strong></td></tr><tr><td>git reset –hard HEAD~100</td><td>回退到第 100 个版本</td></tr><tr><td>cat ‘xxx’</td><td>查看 ‘xxx’ 文件内容</td></tr><tr><td>git reflog</td><td>查看历史记录的版本号 id</td></tr><tr><td><strong>git checkout –  ‘xxx’</strong></td><td><strong>把  ‘xxx’ 文件在工作区的修改全部撤销</strong></td></tr><tr><td>git rm  ‘xxx’</td><td>删除 ‘xxx’ 文件</td></tr><tr><td>git remote add origin &lt;远程库地址&gt;</td><td>关联一个远程库</td></tr><tr><td><strong>git push –u( <em>仅首次使用</em> ) origin master</strong></td><td><strong>把当前 master 分支推送到远程库</strong></td></tr><tr><td><strong>git clone &lt;远程库地址&gt;</strong></td><td><strong>从远程库中克隆</strong></td></tr><tr><td><strong>git checkout –b dev</strong></td><td><strong>创建并切换到 dev 分支上</strong></td></tr><tr><td><strong>git branch</strong></td><td><strong>查看当前所有的分支</strong></td></tr><tr><td><strong>git branch -a</strong></td><td><strong>查看所有的分支</strong></td></tr><tr><td><strong>git checkout &lt;分支名&gt;</strong></td><td><strong>切换回指定分支</strong></td></tr><tr><td>git merge dev</td><td>在当前的分支上合并 dev 分支</td></tr><tr><td>git branch –d dev</td><td>删除 dev 分支</td></tr><tr><td>git branch dev</td><td>创建 dev 分支</td></tr><tr><td>git stash</td><td>把当前的工作隐藏起来 等以后恢复现场后继续工作</td></tr><tr><td>git stash list</td><td>查看所有被隐藏的文件列表</td></tr><tr><td>git stash apply</td><td>恢复被隐藏的文件，但不删除内容</td></tr><tr><td>git stash drop</td><td>删除文件</td></tr><tr><td>git stash pop</td><td>恢复文件的同时 也删除文件</td></tr><tr><td>git remote</td><td>查看远程库的信息</td></tr><tr><td>git remote –v</td><td>查看远程库的详细信息</td></tr><tr><td><strong>git remote set-url origin <url></strong></td><td><strong>设置远程库地址</strong></td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://p3terx.com/archives/git-common-command-quick-lookup-table.html">Git 常用命令速查表</a></li><li><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解 Git 命令</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 全局字体之思源宋体</title>
    <link href="/2020/10/01/2020-10-01-Change-Global-Font/"/>
    <url>/2020/10/01/2020-10-01-Change-Global-Font/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直想更换默认的博客文章字体，参考了众多大佬的博客设计，想换点不一样的字体。</p><p>鉴于本博客主要以中文内容为主，最终选择思源宋体作为博客的正文展示，文章整体显得比较得体和大气！</p><h2 id="1-Fluid-主题"><a href="#1-Fluid-主题" class="headerlink" title="1. Fluid 主题"></a>1. Fluid 主题</h2><h3 id="1-1-导入-Google-字库"><a href="#1-1-导入-Google-字库" class="headerlink" title="1.1 导入 Google 字库"></a>1.1 导入 Google 字库</h3><p>打开 Fluid 主题配置文件 <code>fluid/_config.yml</code>，在自定义 html 处引入字库</p><pre><code class="hljs yaml"><span class="hljs-attr">custom_html:</span>     <span class="hljs-string">&#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/css?family=Noto+Serif+SC&quot;&gt;&#x27;</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201003214436.png" alt="image-20201003214432936"></p><h3 id="1-2-配置全局字体"><a href="#1-2-配置全局字体" class="headerlink" title="1.2 配置全局字体"></a>1.2 配置全局字体</h3><p>同时设置 <code>font_family</code> 为 <strong>Noto Serif SC</strong></p><pre><code class="hljs yaml"><span class="hljs-attr">font:</span>  <span class="hljs-comment"># 主题字体配置</span>  <span class="hljs-attr">font_size:</span> <span class="hljs-string">18px</span>                   <span class="hljs-comment"># 全局字号</span>  <span class="hljs-attr">font_family:</span> <span class="hljs-string">&quot;Noto Serif SC&quot;</span>      <span class="hljs-comment"># 全局字体</span>  <span class="hljs-attr">code_font_size:</span> <span class="hljs-string">18px</span>              <span class="hljs-comment"># 代码的字号</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201003214334.png" alt="image-20201003214331716"></p><h2 id="2-Butterfly-主题"><a href="#2-Butterfly-主题" class="headerlink" title="2. Butterfly 主题"></a>2. Butterfly 主题</h2><p>​    更换 Butterfly 主题的字库可以仅在<code>_config.yml</code>中设置，也可按照下面的方法进行魔改。</p><h3 id="2-1-导入-Google-字库"><a href="#2-1-导入-Google-字库" class="headerlink" title="2.1 导入 Google 字库"></a>2.1 导入 Google 字库</h3><p>打开文件 <code>layout/includes/additional-js.pug</code>，把如下代码复制到顶部</p><pre><code class="hljs routeros">link(<span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>, <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;https://fonts.googleapis.com/css?family=Noto+Serif+SC&quot;</span>)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201001002937.png" alt="image-20201001002932977"></p><h3 id="2-2-配置全局字体"><a href="#2-2-配置全局字体" class="headerlink" title="2.2 配置全局字体"></a>2.2 配置全局字体</h3><p>打开文件 <code>source/css/var.styl</code>，替换相应的代码</p><pre><code class="hljs stylus"><span class="hljs-variable">$dafault</span>-<span class="hljs-attribute">font-family</span> = <span class="hljs-string">&#x27;Noto Serif SC&#x27;</span>, serif</code></pre><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20201001002945.png" alt="image-20201001002944343"></p><p>完成上述两个步骤，字体替换完成！:)</p><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h2><p>感谢博主的分享😀</p><ul><li><a href="https://blog.shenshilei.site/post/29e3">Butterfly主题更换思源宋体</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Butterfly</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程之 ThreadLocal</title>
    <link href="/2020/09/30/ThreadLocal/"/>
    <url>/2020/09/30/ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h3 id="多线程之-ThreadLocal"><a href="#多线程之-ThreadLocal" class="headerlink" title="多线程之 ThreadLocal"></a>多线程之 ThreadLocal</h3><hr><h4 id="1-ThreadLocal-简介"><a href="#1-ThreadLocal-简介" class="headerlink" title="1. ThreadLocal 简介"></a>1. ThreadLocal 简介</h4><p>​    <strong>一个线程可拥有多个 ThreadLocal</strong>，<strong>等价于Thread 的局部变量</strong>。</p><p>​    ThreadLocal 提供了<strong>线程内存储私有变量</strong>的能力，这些变量不同之处在于每一个线程读取的变量是对应的<strong>互相独立的</strong>。</p><p>​    通过 <strong>get 和 set 方法</strong>就可以得到当前线程对应的值，从而避免了线程安全的问题。</p><p>​    ThreadLocal 的使用方法很简单，与 map 类似</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;T&gt; sThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;T&gt;();sThreadLocal.set()sThreadLocal.get()</code></pre><h4 id="2-ThreadLocal-底层原理"><a href="#2-ThreadLocal-底层原理" class="headerlink" title="2. ThreadLocal 底层原理"></a>2. ThreadLocal 底层原理</h4><p>​        <strong>ThreadLocal内存结构图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20200930152613.png" alt="image-20200905225631296"></p><p>​    由结构图是可以看出：</p><ul><li>Thread对象中持有一个ThreadLocal.ThreadLocalMap 的成员变量。</li><li>ThreadLocalMap内部维护了Entry数组，每个Entry代表一个完整的对象，<strong>key是 ThreadLocal 本身，value是 ThreadLocal 的泛型值</strong>。</li></ul><p>几段关键源码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;   <span class="hljs-comment">//ThreadLocal.ThreadLocalMap是Thread的属性</span>   ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>;&#125;</code></pre><p>ThreadLocal中的关键方法 <strong>set() 和 get()</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;    Thread t = Thread.currentThread(); <span class="hljs-comment">// 获取当前线程t</span>    ThreadLocalMap map = getMap(t);  <span class="hljs-comment">// 根据当前线程获取到ThreadLocalMap</span>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)        map.set(<span class="hljs-keyword">this</span>, value); <span class="hljs-comment">// K，V设置到ThreadLocalMap中</span>    <span class="hljs-keyword">else</span>        createMap(t, value); <span class="hljs-comment">// 创建一个新的ThreadLocalMap</span>&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;    Thread t = Thread.currentThread();<span class="hljs-comment">// 获取当前线程t</span>    ThreadLocalMap map = getMap(t);<span class="hljs-comment">// 根据当前线程获取到ThreadLocalMap</span>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-comment">// 由this（即ThreadLoca对象）得到对应的Value，即ThreadLocal的泛型值</span>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>            T result = (T)e.value;             <span class="hljs-keyword">return</span> result;        &#125;    &#125;    <span class="hljs-keyword">return</span> setInitialValue();&#125;</code></pre><h4 id="3-ThreadLocal-内存泄露问题"><a href="#3-ThreadLocal-内存泄露问题" class="headerlink" title="3. ThreadLocal 内存泄露问题"></a>3. ThreadLocal 内存泄露问题</h4><p>​        ThreadLocalMap 所使用的的 key 为 ThreadLocal 的弱引用，而 value 为强引用，这表示在垃圾回收时，key 会被清理掉而 value 则不会，这样导致 <strong>value 会一直占用</strong>，无法被 GC 回收，导致<strong>内存泄漏</strong>问题。因此在使用完 ThreadLocal 的方法后，需要手动调用 <strong><em>remove() 方法</em></strong>，<strong>清空 key 为 null 的记录</strong>。</p><p><strong>ThreadLocal 引用示意图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/vin9712/cdnRes@cdn/blog/hexo/img/2020/20200930152620.jpg" alt="img"></p><p><strong>弱引用代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span>Object value;    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<span class="hljs-keyword">super</span>(k);value = v;&#125;&#125;</code></pre><p><strong>弱引用简介</strong></p><blockquote><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无</strong>的生活用品。弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会<strong>回收它的内存</strong>。</p></blockquote><h4 id="4-ThreadLocal的应用场景"><a href="#4-ThreadLocal的应用场景" class="headerlink" title="4. ThreadLocal的应用场景"></a>4. ThreadLocal的应用场景</h4><ul><li>数据库连接池</li><li>会话管理中使用</li></ul><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><p>​    ThreadLocal 和 Synchronized 都是为了解决多线程中相同变量的访问冲突问题，不同的点是</p><ul><li>Synchronized 是通过<strong>线程等待，牺牲时间</strong>来解决访问冲突，ThreadLocal是通过<strong>每个线程单独一份存储空间，牺牲空间</strong>来解决冲突。</li><li>ThreadLocal 具有 <strong><em>线程隔离</em></strong> 的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 面试题</title>
    <link href="/2020/09/19/mysql/"/>
    <url>/2020/09/19/mysql/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="1-MySQL-的-MylSAM-和-InnoDB-存储引擎的区别是啥？"><a href="#1-MySQL-的-MylSAM-和-InnoDB-存储引擎的区别是啥？" class="headerlink" title="1. MySQL 的 MylSAM 和 InnoDB 存储引擎的区别是啥？"></a>1. MySQL 的 MylSAM 和 InnoDB 存储引擎的区别是啥？</h4><p>​        <strong>MyISAM</strong> 不支持事务和外键约束，<strong>索引文件和数据文件分开</strong>，这样在内存中可以缓存更多的索引，对查询的性能会更好，适用于<strong>少量插入大量查询</strong>的场景。</p><p>​        <strong>InnoDB</strong> 是现在最常用的存储引擎，是 mysql 5.5 之后的默认存储引擎。主要特点就是<strong>支持事务</strong>，走聚簇索引，<strong>强制要求有主键</strong>，支持外键约束，高并发、大数据量、高可用等相关成熟的数据库架构，**<a href="./DepotsTable.md">分库分表</a><strong>、</strong><a href="./RnWSeperate.md">读写分离</a><strong>、</strong>==主备切换==**，全部都可以基于innodb存储引擎来实现。</p><h4 id="2-MySQL索引的原理和数据结构能介绍一下么？"><a href="#2-MySQL索引的原理和数据结构能介绍一下么？" class="headerlink" title="2. MySQL索引的原理和数据结构能介绍一下么？"></a>2. MySQL索引的原理和数据结构能介绍一下么？</h4><h5 id="2-1-索引的分类"><a href="#2-1-索引的分类" class="headerlink" title="2.1 索引的分类"></a>2.1 索引的分类</h5><ol><li><p>从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引</p><ol start="2"><li>从应用层次来分：普通索引，唯一索引，复合索引</li><li>根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引</li></ol></li></ol><ul><li><strong>普通索引</strong>：即一个索引只包含单个列，一个表可以有多个单列索引</li><li><strong>唯一索引</strong>：索引列的值必须唯一，但允许有空值</li><li><strong>复合索引</strong>：即一个索引包含多个列</li><li><strong>==聚簇索引==</strong>(聚集索引)：<strong>索引结构和数据一起存放的索引，主键索引属于聚集索引</strong>。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。优点是能<strong>快速定位数据</strong>，缺点是<strong>依赖于有序的数据</strong>以及<strong>更新代价大</strong>。</li><li><strong>非聚簇索引：</strong>不是聚簇索引，<strong>即索引结构和数据分开存放的索引</strong>。</li></ul><h5 id="2-2-B-Tree-和-B-Tree-对比"><a href="#2-2-B-Tree-和-B-Tree-对比" class="headerlink" title="2.2 B-Tree 和 B+Tree 对比"></a>2.2 B-Tree 和 B+Tree 对比</h5><p>​    使用数据举例，分别插入 15, 56, 77, 20, 49。观察两者区别</p><p>​    B-Tree: <img src="img/B%E6%A0%91.gif" alt="B树">     B+Tree: <img src="img/B+%E6%A0%91.gif" alt="B+树"></p><p>​    <strong>B-Tree 索引结构图</strong></p><p>​    B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。</p><p><img src="img/image-20200830175244040.png" alt="B-Tree"></p><p>​    <strong>==B+Tree 索引结构图==</strong> (<strong>MySQL 存储引擎</strong>)</p><p><img src="img/image-20200830175348540.png" alt="B+Tree"></p><p><strong>B+Tree相对于B-Tree有几点不同</strong></p><ol><li>非叶子节点只存储键值信息。</li><li>所有叶子节点之间都有一个链指针。</li><li>数据记录都存放在叶子节点中。</li></ol><h5 id="2-3-MyISM-和-InnoDB-存储引擎的索引实现"><a href="#2-3-MyISM-和-InnoDB-存储引擎的索引实现" class="headerlink" title="2.3 MyISM 和 InnoDB 存储引擎的索引实现"></a>2.3 MyISM 和 InnoDB 存储引擎的索引实现</h5><ul><li><p>MyISM 存储引擎中的实现</p><p>MyISAM 是<strong>索引文件和数据文件分开</strong>的，其中 <strong>id 为索引</strong>，<strong>data 为数据文件的物理地址</strong>。</p></li></ul><p><img src="img/201805191452_953.png" alt="MyISM"></p><ul><li><p>InnoDB 存储引擎中的实现</p><p>InnoDB 的数据文件本身就是个索引文件，<strong>id 是主键 key，data 为主键 key 数据的所在行的完整数据</strong>。</p><p>此外，InnoDB 引擎会根据主键建立一个默认索引，叫做<strong>聚簇索引</strong>，故要保证主键是唯一的。</p><p><img src="img/image-20200830183621936.png" alt="InnoDB_1"></p></li></ul><p>​    若对某个非主键的字段创建了索引，那么其 data 的值就是主键，再根据主键到聚簇索引里根据主键值再次查找到数据，即所谓的回表（<strong>二级索引</strong>）。</p><p>​    查找过程：<strong>建立非主键key的索引 -&gt; 主键key -&gt; key所在行的数据</strong></p><p><img src="img/image-20200830181841720.png" alt="InnoDB_2"></p><h5 id="2-4-索引的使用规则（MySQL性能优化）"><a href="#2-4-索引的使用规则（MySQL性能优化）" class="headerlink" title="2.4 索引的使用规则（MySQL性能优化）"></a>2.4 索引的使用规则（MySQL性能优化）</h5><ul><li><p><strong>全列匹配索引</strong></p><p>建立的复合索引包括了列的每个字段，同时严格按照索引顺序查询，这样查询效率是最高的。</p><pre><code class="hljs mysql"># 创建全列索引ALTER TABLE &lt;表名&gt; ADD INDEX &lt;索引名&gt;(col1, col2, col3);# 执行查询命令SELECT * FROM WHERE col1 &#x3D; &#39;a&#39; and col2 &#x3D; &#39;b&#39; and col3 &#x3D; &#39;c&#39;;</code></pre></li><li><p>==<strong>最左前缀法则</strong>==</p><p>若建立的是复合索引：a-&gt;b-&gt;c，索引建立顺序是从左到右，想象索引是一条桥，a 为桥头，b 为桥身，c 为桥尾，不可断开。</p><p>那么有如下无效的情形</p><ul><li><p>a -&gt; c：a 有效，c 无效</p></li><li><p>b -&gt; c：b、c 都无效</p></li><li><p>c：c 无效</p></li></ul></li><li><p>以下操作会导致<strong>索引失效</strong></p><ul><li><strong>计算</strong>，如：+、-、*、/、&lt;&gt;、is null、 is not null 等</li><li>聚合函数，如：sum()、round()等</li><li>手动/自动<strong>类型转换</strong>，如：id=“1”，原本id为整数类型，转换为字符串类型了</li><li>索引放在<strong>范围查询右侧(与B+树结构有关)**，如：a-&gt;b-&gt;c，当 where **a=”” and b&gt;10 and ==c=””==</strong> 时，c 用不到索引。</li><li>减少使用 *<em>SELECT **</em>，索引失效的同时会查询很多没必要的字段。尽量使用<strong>覆盖索引</strong>，即 <strong>select 后面的字段 = where 后面的查询条件字段</strong>。</li><li>like <strong>两端模糊查询</strong>，即 where a like %x%，此时使用不到索引，应当<strong>仅保留右百分号(where a like x%)，可使用索引。</strong></li><li>使用 *<em>order by + select **</em>，索引失效且会使用<strong>文件内排序</strong>，即在内存中复制一份一样的数据再排序，性能损耗严重。</li><li><strong>性能损耗</strong>：先排序后分组(group by)，导致索引失效性能损耗；能使用 where 就不使用 having 等。</li></ul></li></ul><ul><li><p>杜绝出现<strong>文件内排序</strong>(filesort)的情况</p><ul><li><p>order by 字段不是索引字段</p></li><li><p>order by 字段是索引字段，但 select 中没有使用覆盖索引，如</p><pre><code class="hljs mysql">select * from test order by age asc;</code></pre></li><li><p>order by 的同时存在升序与降序的排序，如</p><pre><code class="hljs mysql">select a, b from test order by a desc, b, asc;</code></pre></li><li><p>order by 多个字段排序时，不是按照索引的排序进行 order by，即不按照最左前缀法则，如</p><pre><code class="hljs mysql">select a, b from test order by b, a;</code></pre></li></ul></li></ul><h5 id="2-5-索引的缺点及使用建议"><a href="#2-5-索引的缺点及使用建议" class="headerlink" title="2.5 索引的缺点及使用建议"></a>2.5 索引的缺点及使用建议</h5><p>​    索引是有缺点的，比如常见的就是会<strong>增加磁盘消耗</strong>，因为要占用磁盘文件，同时高并发的时候频繁插入和修改索引，会导致<strong>性能损耗</strong>的。</p><p>​    常见做法：</p><ol><li><p>尽量创建<strong>少量的索引</strong>，1个表最多设置3个索引，同时选择该列的值在表中<strong>重复比例较小的字段</strong>来做索引较合适。</p></li><li><p>针对较长的字符串，可建立<strong>前缀索引</strong>，只需匹配有限个字符的子串即可定位所在行。</p><pre><code class="hljs mysql"># 添加前缀索引 (以前4位字符创建前缀索引)alter table test add index(col(4))SELECT col FROM test WHERE col &#x3D; &quot;xxx&quot;</code></pre><p>但其弊端也很明显，即<strong>无法做 group by 和 order by</strong>，页<strong>无法</strong>使用前缀索引做<strong>覆盖扫描</strong>。</p></li></ol><h5 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h5><p>综上，在系统中关于索引的使用，一般就是尽量降低SQL的复杂度，然后搭配上非常简单的<strong>一个主键索引（聚簇索引）+ 少数几个联合索引</strong>，就可以覆盖一个表的所有SQL查询需求了。更加复杂的业务逻辑，让java代码里来实现就ok了。SQL越简单，后续迁移分库分表、读写分离的时候，成本越低，几乎都不用怎么改造SQL。</p><h4 id="3-事务的几个特性是什么？有哪几种隔离级别？"><a href="#3-事务的几个特性是什么？有哪几种隔离级别？" class="headerlink" title="3. 事务的几个特性是什么？有哪几种隔离级别？"></a>3. 事务的几个特性是什么？有哪几种隔离级别？</h4><p><strong>面试官心理分析</strong></p><p>用mysql开发的三个基本面：<strong>存储引擎、索引，事务</strong>。</p><p>因为一个业务系统里，肯定要加事务保证一堆关联操作，要么一起成功要么一起失败，对不对？所以这是聊数据库必问的一个问题</p><p>最最最基本的用mysql来开发，就3点：存储引擎（了解），索引（能建索引，写的SQL都用上索引），事务（了解事务的隔离级别，基于spring的事务支持在代码里加事务）</p><p>存储引擎 -&gt; innodb，索引，基本按照你的SQL的需求都建了索引（可能漏了部分索引忘了建），事务（@Transactional注解，对service层统一加了事务）</p><h5 id="3-1-事务的ACID"><a href="#3-1-事务的ACID" class="headerlink" title="3.1 事务的ACID"></a>3.1 事务的ACID</h5><ol><li>Atomic：<strong>原子性</strong>，一个事务是不可再分割的整体，要么都执行要么都不执行。</li><li>Consistency：<strong>一致性</strong>，一个事务可以使数据从一个一致状态切换到另外一个一致的状态。</li><li>Isolation：<strong>隔离性</strong>，一个事务不受其他事务的干扰，多个事务互相隔离的。</li><li>Durability：<strong>持久性</strong>，一个事务一旦提交了，则永久的持久化到本地。</li></ol><p><img src="img/R3iIriZ.png" alt="img"></p><p><img src="img/UV326rr.png" alt="img"></p><p><strong>简单说，==数据库保证一致性就是由原子性、持久性、隔离性共同保证的结果==。</strong></p><h5 id="3-2-事务的使用步骤"><a href="#3-2-事务的使用步骤" class="headerlink" title="3.2 事务的使用步骤"></a>3.2 事务的使用步骤</h5><ol><li><p><strong>隐式（自动）事务</strong>：没有明显的开启和结束，本身就是一条事务可以<strong>自动提交</strong>，比如insert、update、delete</p></li><li><p>显式事务：具有明显的开启和结束</p><ul><li>开启事务</li></ul><pre><code class="hljs mysql">set autocommit&#x3D;0;start transaction;</code></pre><ul><li>编写一组逻辑 SQL 语句 (如insert、update、delete)，并设置回滚点</li></ul><pre><code class="hljs mysql">insert into &lt;表名&gt; values(a, b, c);savepoint ‘回滚点名’;</code></pre><ul><li><p>结束事务</p><ol><li><p>提交成功</p><pre><code class="hljs mysql">commit;</code></pre></li><li><p>提交失败，则回滚</p><pre><code class="hljs mysql"># 回滚rollback;# 或 回滚到指定的地方rollback to &#39;回滚点名&#39;;</code></pre></li></ol></li></ul></li></ol><h5 id="3-3-事务的隔离级别"><a href="#3-3-事务的隔离级别" class="headerlink" title="3.3 事务的隔离级别"></a>3.3 事务的隔离级别</h5><p><strong>并发问题</strong></p><ol><li><strong>==脏读==**：一个事务读取了其他事务还未提交的数据，读到的是其他事务</strong>==更新==**的数据。</li><li>**==不可重复读==**：一个事务多次读取，结果不一样。</li><li><strong>==幻读==**：一个事务读取了其他事务还未提交的数据，只是读到的是其他事务</strong>==插入==**的数据。</li><li><strong>==更新丢失==</strong> ： 当两个或多个事务<strong>更新同一行记录</strong>，会产生更新丢失现象。可以分为回滚覆盖和提交覆盖。<ul><li>回滚覆盖 ：一个事务回滚操作，把其他事务已提交的数据给覆盖了。</li><li>提交覆盖 ：一个事务提交操作，把其他事务已提交的数据给覆盖了。</li></ul></li></ol><p><strong>隔离级别及可解决的并发问题</strong></p><table><thead><tr><th>事务隔离级别</th><th>回滚覆盖</th><th>脏读</th><th>不可重复读</th><th>提交覆盖</th><th>幻读</th></tr></thead><tbody><tr><td>read uncommitted:读未提交</td><td>✔</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>read committed：读已提交</td><td>✔</td><td>✔</td><td>X</td><td>X</td><td>X</td></tr><tr><td>repeatable read：可重复读</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td><td>X</td></tr><tr><td>serializable：串行化</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td></tr></tbody></table><ol><li><p>Read Uncommitted：<strong>读未提交 **，一个事务在执行过程中可以看到其他事务</strong>未提交的插入和更新的记录**。</p></li><li><p>Read Committed：<strong>读已提交</strong>，一个事务在执行过程中可以看到其他事务<strong>已提交的新插入和更新的记录</strong>。(<strong>==Oracle、SQLServer默认隔离级别==</strong>)</p></li><li><p>Read Repeatable：<strong>可重复读</strong>，一个事务在执行过程中可以看到其他事务<strong>已提交的新插入的记录(<del>看不见更新记录</del>)**。(</strong>==MySQL的默认隔离级别==**)</p></li><li><p>Serializable：<strong>串行化</strong>，所有事务都串行起来，<strong>不允许多个事务并行操作</strong>。</p></li></ol><h5 id="3-4-MySQL是如何实现“可重复读”这一隔离级别的？"><a href="#3-4-MySQL是如何实现“可重复读”这一隔离级别的？" class="headerlink" title="3.4 MySQL是如何实现“可重复读”这一隔离级别的？"></a>3.4 MySQL是如何实现“可重复读”这一隔离级别的？</h5><p>​    MVCC的<strong>简单理解</strong>：如下图所示，<strong>在事务1开始写操作的时候会生成该记录的快照，其他事务读操作会读取这个记录的副本，因此不会影响其他事务对此记录的读取，实现写和读并行。</strong></p><p><img src="img/732QNnZ.png" alt="img"></p><p>​    </p><p>​        MySQL是通过<strong>MVCC机制</strong>来实现<strong>可重复读</strong>的，即多版本并发控制 (<strong>multi-version concurrency control</strong>) 。MVCC支持读和读、读和写、写和读的并行，但为了保证一致性，写和写是无法并行的。<strong>在每次事务修改操作之前，都会在Undo日志中记录修改之前的数据状态和事务号(全局唯一)，该备份记录可以用于其他事务的读取，也可以进行必要时的数据回滚。</strong></p><p>​        MVCC最大的好处是读<strong>不加锁，读写不冲突</strong>。读操作可以分为两类: <strong>快照读</strong>（Snapshot Read）与<strong>当前读</strong> （Current Read）。</p><ul><li><p>快照读：读取的是记录的快照版本（有可能是历史版本），不用加锁。（select）</p></li><li><p>当前读：读取的是记录的最新版本，并且当前读返回的记录，都会加锁，保证其他事务不会再并发</p></li></ul><p>  <strong>举一个记录更新的案例来讲解 MVCC 中多版本的实现：</strong></p><p>  假设 F1～F6 是表中字段的名字，1～6 是其对应的数据。后面三个隐含字段分别对应该行的<strong>隐含ID(行标识)、事务号和回滚指针</strong>，如下图所示。</p><p>  <img src="img/yYrAZnv.png" alt="img"></p><ul><li><p>具体的更新过程如下： 假如一条数据是刚 INSERT 的，DB_ROW_ID 为 1，其他两个字段为空。当事务1更改该行的数据值时，会进行如下操作：</p><p><img src="img/v2eeAnQ.png" alt="img"></p></li></ul><ol><li><p>用<strong>排他锁锁定该行</strong>，<strong>并记录到 Redo log</strong>；</p></li><li><p>把该行<strong>修改前的值复制到 Undo log</strong>，即上图中下面的行；</p></li><li><p>修改当前行的值，<strong>填写事务编号(01)**，使</strong>回滚指针指向 Undo log 中修改前的行**。</p></li></ol><ul><li><p>接下来事务2操作， 过程与事务1相同，此时 Undo log 中会有两行记录，此时查看锁信息，会出现两条 ，并且<strong>通过回滚指针连在一起，通过当前记录的回滚指针回溯到该行创建时的初始内容</strong>，如下图所示：</p><p><img src="img/3qMVZj.png" alt="img"></p><p>MVCC已经实现了读读、读写、写读并发处理，如果想进一步解决写写冲突，可以采用下面两种锁的方案，<strong>乐观锁</strong>和**悲观锁(高并发)**。</p></li></ul><h5 id="3-5-MySql数据库锁的实现原理是什么？如果死锁了怎么办？"><a href="#3-5-MySql数据库锁的实现原理是什么？如果死锁了怎么办？" class="headerlink" title="3.5 MySql数据库锁的实现原理是什么？如果死锁了怎么办？"></a>3.5 MySql数据库锁的实现原理是什么？如果死锁了怎么办？</h5><p><strong>一、锁的分类</strong></p><ol><li>操作的粒度可分为<strong>表级锁</strong>、行级锁和<strong>页级锁</strong>。</li></ol><ul><li>表级锁：每次操作锁住整张表。<strong>锁定粒度大</strong>，发生锁冲突的概率最高，并发度最低。应用在 MyISAM、InnoDB、BDB 等存储引擎中。</li><li>行级锁：每次操作锁住一行数据。<strong>锁定粒度最小</strong>，发生锁冲突的概率最低，并发度最高。应用在<strong>InnoDB 存储引擎</strong>中。</li><li>页级锁：每次锁定相邻的一组记录，锁定粒度界于表锁和行锁之间，开销和加锁时间界于表锁和行锁之间，并发度一般。应用在BDB 存储引擎中。</li></ul><p><strong>MyISAM和InnoDB存储引擎使用的锁</strong></p><p><img src="img/YRRnqeR.png" alt="img"></p><ol start="2"><li>从操作的类型可分为<strong>读锁</strong>和<strong>写锁</strong>。</li></ol><ul><li><p>读锁（S锁）：<strong>共享锁</strong>，针对同一份数据，多个读操作可以同时进行而不会互相影响。</p></li><li><p>写锁（X锁）：<strong>排他锁</strong>，当前写操作没有完成前，它会阻断其他写锁和读锁。</p><p>备注：IS锁、IX锁：意向读锁、意向写锁，属于<strong>表级锁</strong>，S和X主要针对行级锁。在对表记录添加S或X锁之 前，会<strong>先对表添加IS或IX锁</strong>。</p></li></ul><ol start="3"><li>从操作的性能可分为<strong>乐观锁</strong>和<strong>悲观锁</strong>。</li></ol><ul><li>乐观锁：一般的实现方式是对记录数据版本进行比对，在数据更新<strong>提交的时候才会进行冲突检测</strong>，如果发现冲突了，则提示错误信息。(<strong>==类似 Java 的 CAS机制==</strong>)</li><li>悲观锁：在对一条数据修改的时候，为了避免同时被其他人修改，<strong>在修改数据之前先锁定</strong>， 再修改的控制方式。<strong>共享锁和排他锁是悲观锁的不同实现</strong>，但都属于悲观锁范畴。</li></ul><p><strong>二、行锁的原理</strong></p><p>​        在InnoDB引擎中，我们可以使用行锁和表锁，其中行锁又分为共享锁和排他锁。InnoDB行锁是通过对 索引数据页上的记录加锁实现的，主要实现算法有 3 种：<strong>Record Lock</strong>、<strong>Gap Lock</strong> 和 <strong>Next-key Lock</strong>。</p><ul><li><p>RecordLock锁：<strong>锁定单个行记录的锁</strong>。（记录锁，RC、RR隔离级别都支持）</p></li><li><p>GapLock锁：<strong>间隙锁</strong>，锁定索引记录间隙，确保索引记录的间隙不变。（范围锁，RR隔离级别支 持）</p></li><li><p>Next-key Lock 锁： <strong>记录锁和间隙锁组合</strong> ，同时锁住数据，并且<strong>锁住数据前后范围</strong>。（记录锁+范围锁，RR隔离级别支持）</p><p>总结：在“<strong>可重复读</strong>”隔离级别，InnoDB对于记录加锁行为都是<strong>先采用Next-Key Lock</strong>，但是当SQL操作<strong>含有唯一索引时</strong>，Innodb会对Next-Key Lock进行优化，<strong>降级为RecordLock</strong>，<strong>仅锁住索引本身</strong>而非范围。</p></li></ul><p><strong>三、死锁与解决方案</strong></p><ol><li><p><strong>表锁死锁</strong></p><ul><li><p>产生原因： 用户A访问表A（锁住了表A），然后又访问表B；另一个用户B访问表B（锁住了表B），然后企图 访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要 等用户A释放表A才能继续，这就死锁就产生了。</p><p>即：用户A –&gt; A表（表锁）–&gt; B表（表锁）； 用户B –&gt; B表（表锁）–&gt; A表（表锁）</p></li><li><p>解决方案1：这种死锁比较常见，应<strong>尽量按照相同的顺序进行处理</strong> ，尽量避免同时锁定两个资源，如操作A和B两张表时，总是按先A后B的顺序处理， 必须同时锁定两个资源时，要保证在任 何时刻都应该按照相同的顺序来锁定资源。</p></li></ul></li></ol><ol start="2"><li><p><strong>行级锁死锁</strong></p><ul><li>产生原因1： 如果在事务中执行了一条没有索引条件的查询，引发全表扫描，把行级锁上升为全表记录锁定（等 价于表级锁），多个这样的事务执行后，就很容易产生死锁和阻塞，最终应用系统会越来越慢，发 生阻塞或死锁。</li><li>解决方案1： SQL语句中不要使用太复杂的关联多表的查询；使用explain“执行计划”对SQL语句进行分析，对于有全表扫描和全表锁定的SQL语句，建立相应的索引进行优化。</li></ul></li></ol><ul><li><p>产生原因2： 两个事务分别想拿到对方持有的锁，互相等待，于是产生死锁。</p></li><li><p>解决方案2： 在同一个事务中，尽可能做到一次锁定所需要的所有资源 按照id对资源排序，然后按顺序进行处理 </p><p><img src="img/vYNjQbI.png" alt="img"></p></li></ul><ol start="3"><li><strong>共享锁转换为排他锁</strong></li></ol><ol start="4"><li><p><strong>死锁排查</strong></p><p>MySQL提供了几个与锁有关的参数和命令，可以辅助我们优化锁操作，减少死锁发生。</p></li></ol><ul><li>查看死锁日志 通过 <strong>show engine innodb status\G</strong> 命令查看近期<strong>死锁日志信息</strong>。<ul><li>1、查看近期死锁日志信息；</li><li>2、使用explain查看下SQL执行计划</li></ul></li></ul><ul><li><p>查看锁状态变量 通过 <strong>show status like’innodb_row_lock%‘</strong> 命令检查<strong>状态变量</strong>，分析系统中的行锁的争夺情况。</p><pre><code class="hljs sql">Innodb_row_lock_current_waits：当前正在等待锁的数量Innodb_row_lock_time：从系统启动到现在锁定总时间长度Innodb_row_lock_time_avg： 每次等待锁的平均时间Innodb_row_lock_time_max：从系统启动到现在等待最长的一次锁的时间Innodb_row_lock_waits：系统启动后到现在总共等待的次数</code></pre><p>如果等待次数高，而且每次等待时间长，需要分析系统中为什么会有如此多的等待，然后着手定制优化。</p></li></ul><h5 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h5><p>​    <strong>事务底层实现是锁</strong>，在事务控制不了并发的情况下，可以<strong>手动加锁，保证数据一致性</strong>，用执行计划保证索引加在更新列上，禁止锁全表引起死锁，<strong>业务方面可以用MVCC机制防止重复提交</strong>，避免长事务中的数据库加锁开销。</p><h4 id="4-SQL-调优的常用手段"><a href="#4-SQL-调优的常用手段" class="headerlink" title="4. SQL 调优的常用手段"></a>4. SQL 调优的常用手段</h4><p>​    首先要保持SQL简单，一般90%的SQL都建议是单表查询，<strong>join等逻辑放java代码里实现</strong>，不要放SQL里。</p><p>​    如果某个线上SQL跑的慢，首先判断<strong>SQL没有用索引或是数据库选错了索引</strong>，通过看<strong>MySQL的执行计划</strong>来添加索引。其次是考虑<strong>服务器硬件本身和死锁</strong>的问题。</p><pre><code class="hljs mysql"># 查看 SQL 语句的性能explain select * from &#39;表名&#39;</code></pre><p><strong>执行计划中的各个参数意义：</strong></p><ul><li>table：哪个表</li><li><strong>type</strong>：这个很重要，是说类型，all（全表扫描），const（读常量，最多一条记录匹配），eq_ref（走主键，一般就最多一条记录匹配），index（扫描全部索引），range（扫描部分索引）</li><li>possible_keys：显示可能使用的索引</li><li>key：实际使用的索引</li><li>key_len：使用索引的长度</li><li><strong>ref</strong>：联合索引的哪一列被用了</li><li><strong>rows</strong>：一共扫描和返回了多少行</li><li>extra：using filesort（需要额外进行排序），using</li><li>temporary（mysql构建了临时表，比如排序的时候），using</li><li>where（就是对索引扫出来的数据再次根据where来过滤出了结果）</li></ul>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的博客</title>
    <link href="/2020/09/19/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/09/19/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>内容</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/09/19/hello-world/"/>
    <url>/2020/09/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
